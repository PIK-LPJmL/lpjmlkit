#' Submit postprocess
#'
#' postprocess functions are submitted to Slurm based on submitted LPJmL runs
#' \link[lpjmlKit]{submit_lpjml}. `submit_lpjml` returns a tibble that can be
#' used as an input (see `x`). It serves the details to submit single
#' or multiple (dependent/subsequent) postprocess runs.
#'
#' @param x job_details tibble generated by submit_lpjml or character vector of
#' sim_names (output folders) within the output_path directory. If NULL
#' (default) `output_path` is used directly to store stdout, stderr.
#'
#' @param select_sim character vector. Select the simulations to be post
#' processed by their sim_name (output folders). This may be relevant if some
#' of the simulations are Spin-up runs or should not be included directly be
#' processed (e.g. PNV runs). Defaults to NULL.
#'
#' @param output_path character defining the path to create a postprocess
#' folder, a subfolder for each `x` -> *sim_name* (if provided) as a template
#' and to store stdout, stderr files.
#'
#' @param fun either a function object or a non-empty character string naming
#' the function to be passed to be submitted.
#'
#' @param args a list of arguments to the `fun` call. The names attribute
#' of args gives the argument names. **IMPORTANT** `fun` has to have an argument
#' which acts as a placeholder to be filled with each *sim_name* of
#' `x`/`select_sim`. If it should not be `x` please specify via `sim_name_arg`.
#'
#' @param sim_name_arg character string defining the functions `fun` argument the
#' internally iterated *sim_name* is passed to. This argument cannot be defined
#' and works as a placeholder. Defaults to "x".
#'
#' @param sim_name_path boolean. If `TRUE` the *sime_name* is concatenated
#' to a path name as `paste(output_path, "output", sim_name, sep="/")` and passed
#' this way to the `sim_name_arg`. Defaults to `FALSE`.
#'
#' @param group character string, provide a group for which the job is
#' submitted. Default is "lpjml"
#'
#' @param sclass character string, define the job classification, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5).
#' Defaults to "short".
#'
#' @param ntasks integer, define the number of tasks/threads, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#' Defaults to 1.
#'
#' @param return_output boolean. If `TRUE` output of function is saved as *RDS*
#' file to `output_path` -> postprocess with fun_name. Defaults to FALSE
#'
#' @param package_names character vector. Provide package names of the function
#' to be used, or functions to be used inside if not called via
#' package::function annotation. Defaults to NULL
#'
#' @param memory integer. If function requires a lot of RAM allocate memory
#' (in mb). Defaults to NULL
#'
#' @param modules character vector. Modules to be load on the cluster. Please
#' mind that `module purge` is executed before modules are loaded. Defaults to
#' NULL
#'
#' @param no_submit boolean. If TRUE job is not submitted to Slurm - feature is
#' mostly for testing purpose.
#'
#' @return see `x`, extended with columns fun_name and dependence, order if
#' missing.
#'
#' @examples
#'
#' \dontrun{
#' library(lpjmlKit)
#' library(tibble)
#'
#' model_path <- paste0("/home/",Sys.getenv("USER"), "/LPJmL_internal")
#' output_path <-paste0("/home/",Sys.getenv("USER"), "/my_runs")
#'
#' job_details <- tibble(
#'   sim_name = c("scen1_spinup", "scen1_transient"),
#'   random_seed = as.integer(c(1, 42)),
#'   order = c(1, 2),
#'   dependency = c(NA, "scen1_spinup")
#' ) %>%
#'   write_config(model_path, output_path) %>%
#'   submit_lpjml(model_path, output_path) %>%
#'   submit_postprocess(select_sim = c("scen1_transient"),
#'                      output_path = output_path,
#'                      fun = print,
#'                      args = list())
#'
#' job_details
#' #   sim_name        fun_file                 order dependency        job_id status  
#' #   <chr>           <chr>                    <dbl> <chr>              <dbl> <chr>   
#' # 1 scen1_spinup    NA                           1 NA               2123724 submitted
#' # 2 scen1_transient NA                           2 scen1_spinup     2123725 submitted
#' # 3 scen1_transient print                        3 scen1_spinup (2) 2123726 submitted
#' }
#'
#' @md
#' @export
submit_postprocess <- function(x = NULL,
                               select_sim = NULL,
                               output_path,
                               fun,
                               args,
                               sim_name_arg = "x",
                               sim_name_path = FALSE,
                               group = "lpjml",
                               sclass = "short",
                               ntasks = 1,
                               return_output = FALSE,
                               package_names = NULL,
                               memory = NULL,
                               modules = NULL,
                               no_submit = FALSE) {
  if (!dir.exists(output_path)) {
    if (output_path != "TEST/PATH") {
      stop(
        paste0("Folder of output_path \"", output_path, "\" does not exist!")
      )
    }
  }
  # temporarily save function to be called
  fun_file <- tempfile(fileext = ".rds")
  saveRDS(fun, fun_file)

  # temporarily save function arguments to be passed
  args_file <- tempfile(fileext = ".rds")
  saveRDS(args, args_file)

  # get function name
  fun_name <- as.character(substitute(fun))

  # internal submit process function
  submit_process <- function(x,
                             output_path,
                             fun_file,
                             fun_name,
                             args_file,
                             sim_name_arg,
                             sim_name_path,
                             ntasks,
                             sclass,
                             group,
                             return_output,
                             package_names,
                             dependency,
                             memory,
                             modules,
                             no_submit) {

    timestamp <- format(Sys.time(), "%Y%m%d_%H%M")

    # create postprocess directories - recursively if postprocess not existing
    postdir <- paste(output_path, "postprocess", x, sep = "/")
    if (output_path != "TEST/PATH") {
      dir.create(postdir, recursive = TRUE, showWarnings = FALSE)
    }
    # create output_file name to save output in postprocess postdir if required
    if (return_output) {
      output_file <- paste0(postdir, "/", fun_name, "_", timestamp, ".rds")
    } else {
      output_file <- NULL
    }

    # temporarily save function call file called by bash sh script
    funcall_file <- tempfile(fileext = ".R")
    # concatenate R file template with <<tags>> to be replaced
    readLines(system.file(
        "templates/postprocess_r.txt",
        package = utils::packageName()
      )) %>%
        replace_template_tags(
          list(package_names = ifelse(!is.null(package_names),
                                paste0("c(",
                                       paste0("\"",
                                              package_names,
                                              "\"",
                                              collapse = ", "),
                                       ")"),
                                "\"\""),
               fun_name = paste0("\"", fun_name, "\""),
               sim_name = ifelse(
                 sim_name_path,
                 paste0("\"", output_path, "/output/", x, "\""),
                 paste0("\"", x, "\"")
               ),
               fun_file = paste0("\"", fun_file, "\""),
               args_file = paste0("\"", args_file, "\""),
               sim_name_arg = sim_name_arg,
               output_file = paste0("\"", output_file, "\""))
        ) %>%
      writeLines(
        con = funcall_file)

      # temporarily save sbatch script to be called
      sbatch_file <- tempfile(fileext = ".sh")

      # concatenate sh file template with <<tags>> to be replaced
      readLines(system.file(
        "templates/postprocess_sh.txt",
        package = utils::packageName()
      )) %>%
        # replace tags in template with arguments supplied to replace function
        replace_template_tags(
          list(ntasks = ntasks,
               sclass = paste0("\"", sclass, "\""),
               group = paste0("\"", group, "\""),
               stdout = paste0("\"",
                               output_path,
                               "/postprocess/",
                               x,
                               "/outfile_",
                               timestamp,
                               ".out\""),
               stderr = paste0("\"",
                               output_path,
                               "/postprocess/",
                               x,
                               "/errfile_",
                               timestamp,
                               ".err\""),
               workdir = paste0("\"", postdir, "\""),
               dependency = ifelse(!is.null(dependency),
                                   paste0("#SBATCH --dependency=afterok:",
                                          dependency),
                                   ""),
               memory_alloc = ifelse(!is.null(memory),
                                  paste0("\"#SBATCH --mem=", memory, "\""),
                                  ""),
               module_load = ifelse(!is.null(modules),
                              paste0("module purge\n",
                                     paste0("module load ",
                                            modules,
                                            collapse = "\n")),
                              ""),
               rscript_file = paste0("\"", funcall_file, "\""),
               sbatch_file = paste0("\"", sbatch_file, "\""))
        ) %>%
        # write temporary sbatch sh file for slurm job submission
        writeLines(con = sbatch_file)
    if (!no_submit) {
      # submit with processx to end all subprocesses at end and return parasble
      submit_status <- processx::run(command = "sh",
                                     args = c("-c",
                                              paste("sbatch --parsable ",
                                                    sbatch_file)),
                                     cleanup_tree = TRUE)
    } else {
      # object only for no_submit check
      submit_status <- list(status = 501)
    }
    return(submit_status)
  }

  # case for tibble returned by submit_lpjml
  if (any(c("tbl_df", "tbl") %in% class(x)) &
      "lpjml" %in% attr(x, "stages")) {
    sim_names <- unique(x$sim_name)
    # to be used in lpjml_pipe context
    is_pipe <- TRUE
    # check if columns exist otherwise create and assign adequate values
    if (!("fun_name" %in% colnames(x))) x$fun_name <- NA
    if (!("dependency" %in% colnames(x))) x$dependency <- NA
    if (!("order" %in% colnames(x))) x$order <- 1
  # case for character vector to list sim_names (here output folder)
  } else if ("character" %in% class(x)) {
    sim_names <- x
    is_pipe <- FALSE
  # if nothing is provided output_path is assumed to be location of output files
  } else if ("NULL" %in% class(x)) {
    sim_names <- ""
    is_pipe <- FALSE
  } else {
    stop(paste0("x does not have a valid format. ",
                "Use returned object by submit_lpjml or provide ",
                "a vector with sim_names (here the name of each output folder ",
                "in output_path. Or only provide an output_path"))
  }

  # iterate to enable multiple job submits
  for (sim_name in sim_names) {
    # exclude sim_names that are not included in select_sim
    if (!is.null(select_sim)) {
      if (!(sim_name %in% select_sim)) {
        next
      }
    }
    if (is_pipe) {
      which_sim <- which(x$sim_name == sim_name)
      dep_id <- which_sim[which.max(x$order[which_sim])]
    }
    job <- submit_process(sim_name,
                          output_path,
                          fun_file,
                          fun_name,
                          args_file,
                          sim_name_arg,
                          sim_name_path,
                          ntasks,
                          sclass,
                          group,
                          return_output,
                          package_names,
                          switch(is_pipe, x$job_id[dep_id]),
                          memory,
                          modules,
                          no_submit)
    if (is_pipe) {
      # add new row to be adjusted by job status (job_id, status)
      x <- tibble::add_row(x,
                           sim_name = sim_name,
                           fun_name = fun_name,
                           type = "postprocess",
                           order = x$order[dep_id] + 1,
                           dependency = paste0(
                             sim_name,
                             " (",
                             x$order[dep_id],
                             ")"
                           ),
                           job_id = NA,
                           status = "failed")
      # index = last/number of row
      idx <- nrow(x)
      # get job status
      if (job$status == 0) {
        x$job_id[idx] <- strsplit(job$stdout, "\n")[[1]][1]
        x$status[idx] <- "submitted"
      } else if (job$status == 501) {
        x$status[idx] <- "not submitted"
      } else {
        x$status[idx] <- "failed"
      }
      attr(x, "stages") <- append(attr(x, "stages"), fun_name)
    }
  }
  return(x)
}
