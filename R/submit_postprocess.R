#' Submit a post model process to SLURM
#'
#' Postprocess functions are submitted to SLURM based on submitted LPJmL runs
#' \link[lpjmlkit]{submit_lpjml}. `submit_lpjml` returns a tibble that can be
#' used as an input (see `x`). It serves the details to submit single
#' or multiple (dependent/subsequent) postprocess runs.
#'
#' @param x A tibble generated by submit_lpjml or character vector of
#' sim_names (output folders) within the output_path directory. If NULL
#' (default) `output_path` is used directly to store stdout, stderr.
#'
#' @param select_sim Character vector. Select the simulations to be post
#' processed by their sim_name (output folders). This may be relevant if some
#' of the simulations are Spin-up runs or should not be included directly be
#' processed (e.g. PNV runs). Defaults to NULL.
#'
#' @param output_path Character string defining the path to create a postprocess
#' folder, a subfolder for each `x` -> *sim_name* (if provided) as a template
#' and to store stdout, stderr files.
#'
#' @param fun Either a function object or a non-empty character string naming
#' the function to be passed to be submitted.
#'
#' @param args A list of arguments to the `fun` call. The names attribute
#' of args gives the argument names. **IMPORTANT** `fun` has to have an argument
#' which acts as a placeholder to be filled with each *sim_name* of
#' `x`/`select_sim`. If it should not be `x` please specify via `sim_name_arg`.
#'
#' @param sim_name_arg Character string defining the functions `fun` argument the
#' internally iterated *sim_name* is passed to. This argument cannot be defined
#' and works as a placeholder. Defaults to "x".
#'
#' @param sim_name_path Logical. If `TRUE` the *sime_name* is concatenated
#' to a path name as `paste(output_path, "output", sim_name, sep="/")` and passed
#' this way to the `sim_name_arg`. Defaults to `FALSE`.
#'
#' @param group Character string, provides a group for which the job is
#' submitted. Default is "lpjml".
#'
#' @param sclass Character string, defines the job classification, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5). # nolint
#' Defaults to "short".
#'
#' @param ntasks integer, defines the number of tasks/threads, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18). # nolint
#' Defaults to 1.
#'
#' @param return_output Logical. If `TRUE` the output of the function is saved
#' as an *RDS* file to the `output_path` -> postprocess with fun_name.
#' Defaults to FALSE.
#'
#' @param package_names Character vector. Provides package names of the functions
#' to be used, or functions to be used inside if not called via
#' package::function annotation. Defaults to NULL.
#'
#' @param memory Integer. If a function requires a lot of RAM allocate required
#' memory (in mb). Defaults to NULL.
#'
#' @param modules Character vector. Modules to be loaded on the cluster. Please
#' keep in mind that `module purge` is executed before the modules are loaded.
#' Defaults to NULL.
#'
#' @param no_submit Logical. If TRUE the job is not submitted to SLURM - this
#' feature is' mostly for testing purpose.
#'
#' @return See `x`, extended by columns fun_name and dependency, order if
#' missing.
#'
#' @examples
#'
#' \dontrun{
#' library(lpjmlkit)
#' library(tibble)
#'
#' model_path <- paste0("/home/",Sys.getenv("USER"), "/LPJmL_internal")
#' output_path <-paste0("/home/",Sys.getenv("USER"), "/my_runs")
#'
#' job_details <- tibble(
#'   sim_name = c("scen1_spinup", "scen1_transient"),
#'   random_seed = as.integer(c(1, 42)),
#'   order = c(1, 2),
#'   dependency = c(NA, "scen1_spinup")
#' ) %>%
#'   write_config(model_path, output_path) %>%
#'   submit_lpjml(model_path, output_path) %>%
#'   submit_postprocess(select_sim = c("scen1_transient"),
#'                      output_path = output_path,
#'                      fun = print,
#'                      args = list())
#'
#' job_details
#' #   sim_name        fun_file                 order dependency        job_id status
#' #   <chr>           <chr>                    <dbl> <chr>              <dbl> <chr>
#' # 1 scen1_spinup    NA                           1 NA               2123724 submitted
#' # 2 scen1_transient NA                           2 scen1_spinup     2123725 submitted
#' # 3 scen1_transient print                        3 scen1_spinup (2) 2123726 submitted
#' }
#'
#' @md
#' @export
submit_postprocess <- function(x = NULL,
                               select_sim = NULL,
                               output_path,
                               fun,
                               args,
                               sim_name_arg = "x",
                               sim_name_path = FALSE,
                               group = "lpjml",
                               sclass = "short",
                               ntasks = 1,
                               return_output = FALSE,
                               package_names = NULL,
                               memory = NULL,
                               modules = NULL,
                               no_submit = FALSE) {

  # Check if slurm is available.
  if (!is_slurm_available() && !no_submit) {
    stop("submit_postprocess is only available on the PIK cluster environment")
  }

  if (!dir.exists(output_path)) {
    if (output_path != "TEST/PATH") {
      stop(
        paste0("Folder of output_path \"", output_path, "\" does not exist!")
      )
    }
  }

  # Temporarily save function to be called.
  fun_file <- tempfile(fileext = ".rds")
  saveRDS(fun, fun_file)

  # Temporarily save function arguments to be passed.
  args_file <- tempfile(fileext = ".rds")
  saveRDS(args, args_file)

  # Get function name.
  fun_name <- as.character(substitute(fun))

  # Case for tibble returned by submit_lpjml.
  if (any(c("tbl_df", "tbl") %in% class(x)) &&
      "lpjml" %in% attr(x, "stages")) {

    sim_names <- unique(x$sim_name)

    # To be used in lpjml pipe context.
    is_pipe <- TRUE

    # Check if columns exist otherwise create and assign adequate values.
    if (!("fun_name" %in% colnames(x))) x$fun_name <- NA
    if (!("dependency" %in% colnames(x))) x$dependency <- NA
    if (!("order" %in% colnames(x))) x$order <- 1

  # Case for character vector to list sim_names (here output folder).
  } else if ("character" %in% class(x)) {
    sim_names <- x
    is_pipe <- FALSE

  # If nothing is provided output_path is assumed to be location of output files.
  } else if ("NULL" %in% class(x)) {
    sim_names <- ""
    is_pipe <- FALSE

  } else {
    stop(paste0("x does not have a valid format. ",
                "Use returned object by submit_lpjml or provide ",
                "a vector with sim_names (here the name of each output folder ",
                "in output_path. Or only provide an output_path"))
  }

  # Iterate to enable multiple job submits.
  for (sim_name in sim_names) {

    # Exclude sim_names that are not included in select_sim.
    if (!is.null(select_sim)) {
      if (!(sim_name %in% select_sim)) {
        next
      }
    }

    if (is_pipe) {
      which_sim <- which(x$sim_name == sim_name)
      dep_id <- which_sim[which.max(x$order[which_sim])]
    }

    job <- submit_process(sim_name,
                          output_path,
                          fun_file,
                          fun_name,
                          args_file,
                          sim_name_arg,
                          sim_name_path,
                          ntasks,
                          sclass,
                          group,
                          return_output,
                          package_names,
                          switch(is_pipe, x$job_id[dep_id]),
                          memory,
                          modules,
                          no_submit)

    if (is_pipe) {

      # Add new row to be adjusted by job status (job_id, status).
      x <- tibble::add_row(x,
                           sim_name = sim_name,
                           fun_name = fun_name,
                           type = "postprocess",
                           order = x$order[dep_id] + 1,
                           dependency = paste0(
                             sim_name,
                             " (",
                             x$order[dep_id],
                             ")"
                           ),
                           job_id = NA,
                           status = "failed")

      # Index = last/number of row.
      idx <- nrow(x)

      # Get job status.
      if (job$status == 0) {
        x$job_id[idx] <- strsplit(job$stdout, "\n")[[1]][1]
        x$status[idx] <- "submitted"

      } else if (job$status == 501) {
        x$status[idx] <- "not submitted"

      } else {
        x$status[idx] <- "failed"
      }

      attr(x, "stages") <- append(attr(x, "stages"), fun_name)
    }
  }

  return(x)
}


  # Internal submit process function.
submit_process <- function(x,
                           output_path,
                           fun_file,
                           fun_name,
                           args_file,
                           sim_name_arg,
                           sim_name_path,
                           ntasks,
                           sclass,
                           group,
                           return_output,
                           package_names,
                           dependency,
                           memory,
                           modules,
                           no_submit) {

  timestamp <- format(Sys.time(), "%Y%m%d_%H%M")

  # Create postprocess directories - recursively if postprocess not existing.
  postdir <- paste(output_path, "postprocess", x, sep = "/")
  if (output_path != "TEST/PATH") {
    dir.create(postdir, recursive = TRUE, showWarnings = FALSE)
  }

  # Create output_file name to save output in postprocess postdir if required.
  if (return_output) {
    output_file <- paste0(postdir, "/", fun_name, "_", timestamp, ".rds")
  } else {
    output_file <- NULL
  }

  # Temporarily save function call file called by bash sh script.
  funcall_file <- tempfile(fileext = ".R")

  # Concatenate R file template with <<tags>> to be replaced.
  readLines(system.file(
      "templates/postprocess_r.txt",
      package = utils::packageName()
    )) %>%

      replace_template_tags(
        list(package_names = ifelse(!is.null(package_names),
                              paste0("c(",
                                     paste0("\"",
                                            package_names,
                                            "\"",
                                            collapse = ", "),
                                     ")"),
                              "\"\""),
             fun_name = paste0("\"", fun_name, "\""),
             sim_name = ifelse(
               sim_name_path,
               paste0("\"", output_path, "/output/", x, "\""),
               paste0("\"", x, "\"")
             ),
             fun_file = paste0("\"", fun_file, "\""),
             args_file = paste0("\"", args_file, "\""),
             sim_name_arg = sim_name_arg,
             output_file = paste0("\"", output_file, "\""))
      ) %>%

    writeLines(
      con = funcall_file)

    # Temporarily save sbatch script to be called.
    sbatch_file <- tempfile(fileext = ".sh")

    # Concatenate sh file template with <<tags>> to be replaced.
    readLines(system.file(
      "templates/postprocess_sh.txt",
      package = utils::packageName()
    )) %>%

      # Replace tags in template with arguments supplied to replace function.
      replace_template_tags(
        list(ntasks = ntasks,
             sclass = paste0("\"", sclass, "\""),
             group = paste0("\"", group, "\""),
             stdout = paste0("\"",
                             output_path,
                             "/postprocess/",
                             x,
                             "/outfile_",
                             timestamp,
                             ".out\""),
             stderr = paste0("\"",
                             output_path,
                             "/postprocess/",
                             x,
                             "/errfile_",
                             timestamp,
                             ".err\""),
             workdir = paste0("\"", postdir, "\""),
             dependency = ifelse(!is.null(dependency),
                                 paste0("#SBATCH --dependency=afterok:",
                                        dependency),
                                 ""),
             memory_alloc = ifelse(!is.null(memory),
                                paste0("\"#SBATCH --mem=", memory, "\""),
                                ""),
             module_load = ifelse(!is.null(modules),
                            paste0("module purge\n",
                                   paste0("module load ",
                                          modules,
                                          collapse = "\n")),
                            ""),
             rscript_file = paste0("\"", funcall_file, "\""),
             sbatch_file = paste0("\"", sbatch_file, "\""))
      ) %>%

      # Write temporary sbatch sh file for slurm job submission.
      writeLines(con = sbatch_file)

  if (!no_submit) {

    # Submit with processx to end all subprocesses at end and return parasble.
    submit_status <- processx::run(command = "sh",
                                   args = c("-c",
                                            paste("sbatch --parsable ",
                                                  sbatch_file)),
                                   cleanup_tree = TRUE)

  } else {

    # Object only for no_submit check.
    submit_status <- list(status = 501)
  }

  return(submit_status)
}


# Function to replace a template tag, convention here: <<tag_name>>. Recursive
#   style to handle multiple tag lists
#   x has to be a character (vector) and tags a list with named tag replacements.
replace_template_tags <- function(x, tags) {
  . <- NULL

  x <- tags[1] %>%
    gsub(pattern = paste0("<<", names(.), ">>"),
         replacement = .,
         x = x)

  if (length(tags) > 1) {
    return(replace_template_tags(x, tags[c(-1)]))

  } else {
    return(x)
  }
}
