#' Submit LPJmL
#'
#' LPJmL runs are submitted to Slurm using config*.json files written by
#' \link[lpjmlKit]{write_config}. `write_config` returns a tibble that can be
#' used as an input (see `run_details`). It serves the details to submit sinlge
#' or multiple (dependent/subsequent) model runs.
#'
#' @param run_details tibble with at least "sim_name" defined as columns.
#' Runs as rows. Optional pseudo parameters "order" and
#' "dependency" used for subsequent runs (see details). Hint:
#' \link[lpjmlKit]{write_config} returns a tibble in the required format
#'
#' @param model_path character string providing the path to LPJmL
#' (equal to LPJROOT)
#'
#' @param output_path character string - if output_path differs from
#' model_path - path where an output, a restart and a configuration
#' folder are created
#'
#' @param group character string, provide a group for which the job is
#' submitted. Default is "lpjml"
#'
#' @param sclass character string, define the job classification, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5).
#' Defaults to "short".
#'
#' @param ntasks integer, define the number of tasks/threads, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#'
#' @param wtime character string, defining the time limit which can be an
#' advantage to get faster to the top of the (s)queue. For more information
#' have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#'
#' @param blocking integer, cores to be blocked. For more information
#' have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#'
#' @param no_submit boolean, do not submit to slurm - use to test if
#' `run_details` set correctly
#'
#' @return see `run_details`, extended with columns "job_id" and "status".
#'
#' @details
#'
#' Supply a \link[tibble]{tibble} for `run_details` in the form
#' of (random example), generated by \link[lpjmlKit]{write_config}:
#'
#' | **sim_name**    |
#' |:--------------- |
#' | scen1_spinup    |
#' | scen2_transient |
#'
#' To perform subsequent runs provide pseudo parameters order and dependency
#' as in the following example:
#'
#' | **sim_name**    | **order** | **dependency** |
#' |:--------------- | ---------:|:-------------- |
#' | scen1_spinup    | 1         | NA             |
#' | scen2_transient | 2         | scen1 _spinup  |
#'
#' @examples
#'
#' \dontrun{
#' library(lpjmlKit)
#' library(tibble)
#'
#' model_path <- paste0("/home/",Sys.getenv("USER"), "/LPJmL_internal")
#' output_path <-paste0("/home/",Sys.getenv("USER"), "/my_runs")
#'
#' # basic
#' my_params <- tibble(
#'  sim_name = c("scen1", "scen2"),
#'  random_seed = as.integer(c(42, 666)),
#'  pftpar.1.name = c("first_tree", NA),
#'  param.k_temp = c(NA, 0.03),
#'  firewood = c(TRUE, FALSE)
#' )
#' config_details <- write_config(my_params, model_path, output_path)
#' run_details <- submit_lpjml(run_details = config_details,
#'                             model_path = model_path,
#'                             output_path = output_path)
#'
#' run_details
#' #   sim_name      job_id   status       
#' #   <chr>           <int>  <chr>        
#' # 1 scen1         2123525  submitted    
#' # 2 scen2         2123526  submitted    
#'
#' # with dependent runs and pipe notations
#' run_details2 <- tibble(
#'   sim_name = c("scen1_spinup", "scen1_transient"),
#'   random_seed = as.integer(c(1, 42)),
#'   order = c(1, 2),
#'   dependency = c(NA, "scen1_spinup")
#' ) %>%
#'   write_config(my_params, model_path, output_path) %>%
#'   submit_lpjml(model_path, output_path)
#'
#' run_details2
#' #   sim_name        order dependency     job_id status       
#' #   <chr>           <dbl> <chr>           <dbl> <chr>        
#' # 1 scen1_spinup        1 NA            2123525 not submitted
#' # 2 scen1_transient     2 scen1_spinup  2123526 not submitted
#'
#' }
#'
#' @export
submit_lpjml <- function(run_details,
                         model_path,
                         output_path = NULL,
                         group = "lpjml",
                         sclass = "short",
                         ntasks = 256,
                         wtime = "",
                         blocking = "",
                         no_submit = FALSE) {
  # if (any(c("tbl_df", "tbl") %in% class(x)) &
  #     "config" %in% attr(run_details, "stages")) {
  #   stop(paste0("x does not have a valid format. ",
  #               "Use returned object of write_config as run_details."))
  # }
  if (!dir.exists(model_path)) {
    if (model_path != "TEST/PATH") {
      stop(
        paste0("Folder of model_path \"", model_path, "\" does not exist!")
      )
    }
  }
  if (is.null(output_path)) output_path <- model_path

  # internal submit run function
  submit_run <- function(sim_name,
                         model_path,
                         output_path,
                         group,
                         sclass,
                         ntasks,
                         wtime,
                         blocking,
                         dependency) {
    config_file <- paste0("config_",
                          sim_name,
                          ".json")

    timestamp <- format(Sys.time(), "%Y%m%d_%H%M")
    stdout <- paste0(output_path,
                    "/output/",
                    sim_name,
                    "/",
                    "outfile_",
                    timestamp,
                    ".out")
    stderr <- paste0(output_path,
                    "/output/",
                    sim_name,
                    "/",
                    "errfile_",
                    timestamp,
                    ".err")
    inner_command <-  paste0(model_path, "/bin/lpjsubmit",
                             " -nocheck",
                             " -class ", sclass,
                             " -group ", group,
                             ifelse(wtime != "",
                                    paste0(" -wtime ", wtime),
                                    ""),
                             ifelse(blocking != "",
                                    paste0(" -blocking ", blocking),
                                    ""),
                             ifelse(!is.na(dependency),
                                    paste0(" -dependency ", dependency),
                                    ""),
                             " -o ", stdout,
                             " -e ", stderr,
                             " ",
                             ntasks,
                             " ",
                             output_path,
                             "/configurations/",
                             config_file)
    submit_status <- processx::run(command = "sh",
                                   args = c("-c", inner_command),
                                   cleanup_tree = TRUE)
    return(submit_status)
  }
  run_details$type <- rep("simulation", nrow(run_details))
  run_details$job_id <- rep(NA, nrow(run_details))
  run_details$status <- rep("failed", nrow(run_details))

  if ("order" %in% colnames(run_details)) {
    for (order in unique(sort(run_details$order))) {
      sim_names <- run_details$sim_name[
        which(run_details$order == order)
      ]
      for (sim_name in sim_names) {
        sim_idx <- which(run_details$sim_name == sim_name)
        dep_sim_name <- run_details$dependency[sim_idx]
        if (!is.na(dep_sim_name)) {
          dependency <- run_details$job_id[sim_idx]
        } else {
          dependency <- NA
        }
        if (!no_submit) {
          job <- submit_run(sim_name,
                            model_path,
                            output_path,
                            group,
                            sclass,
                            ntasks,
                            wtime,
                            blocking,
                            dependency)
          if (job$status == 0) {
            run_details$job_id[sim_idx] <- strsplit(
              strsplit(job$stdout, "Submitted batch job ")[[1]][2], "\n"
            )[[1]][1]
            run_details$status[sim_idx] <- "submitted"
          }
        } else {
          run_details$job_id[sim_idx] <- NA
          run_details$status[sim_idx] <- "not submitted"
        }
      }
    }
  } else {
    for (sim_name in run_details$sim_name) {
      sim_idx <- which(run_details$sim_name == sim_name)
      if (!no_submit) {
        job <- submit_run(sim_name,
                          model_path,
                          output_path,
                          group,
                          sclass,
                          ntasks,
                          wtime,
                          blocking,
                          dependency = NA)
        if (job$status == 0) {
          run_details$job_id[sim_idx] <- strsplit(
            strsplit(job$stdout, "Submitted batch job ")[[1]][2], "\n"
          )[[1]][1]
          run_details$status[sim_idx] <- "submitted"
        } else {
          run_details$status[sim_idx] <- "failed"
        }
      } else {
        run_details$job_id[sim_idx] <- NA
        run_details$status[sim_idx] <- "not submitted"
      }
    }
  }
  attr(run_details, "stages") <- append(attr(run_details, "stages"), "lpjml")
  return(run_details)
}