#' Submit LPJmL
#'
#' LPJmL runs are submitted to Slurm using `"config*.json"` files written by
#' \link[lpjmlkit]{write_config}. \link[lpjmlkit]{write_config} returns a tibble
#' that can be used as an input (see `x`). It serves the details to submit
#' single or multiple (dependent/subsequent) model runs.
#'
#' @param x \link[tibble]{tibble} with at least "sim_name" defined as columns.
#' Runs as rows. Optional run parameters `"dependency"` used for subsequent runs
#' (see details) \link[lpjmlkit]{write_config} returns a tibble in the required
#' format. OR provide a character string (vector) with the file name of a or
#' multiple generated ( \link[lpjmlkit]{write_config}) config file(s).
#'
#' @param model_path character string providing the path to LPJmL
#' (equal to LPJROOT)
#'
#' @param output_path character string - if `output_path` differs from
#' `model_path` - path where an output, a restart and a configuration
#' folder are created
#'
#' @param group character string, provide a group for which the job is
#' submitted. Default is `"lpjml"`
#'
#' @param sclass character string, define the job classification, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5). # nolint
#' Defaults to `"short"`
#'
#' @param ntasks integer, define the number of tasks/threads, for more
#' information have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18). # nolint
#' Defaults to 256.
#'
#' @param wtime character string, defining the time limit which can be an
#' advantage to get faster to the top of the (s)queue. For more information
#' have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#'
#' @param blocking integer, cores to be blocked. For more information
#' have a look [here](https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18).
#'
#' @param no_submit logical, do not submit to slurm - use to test if
#' `x` set correctly
#'
#' @return see `x`, extended with columns `"type"`, `"job_id"` and `"status"`.
#'
#' @details
#' Supply a \link[tibble]{tibble} for `x` that has been generated by
#' \link[lpjmlkit]{write_config} and can look like the following examples:
#'
#' | **sim_name**    |
#' |:--------------- |
#' | scen1_spinup    |
#' | scen2_transient |
#'
#' To perform subsequent or rather nested runs provide optional run parameter
#' `"dependency"` to the initial \link[tibble]{tibble} supplied as `param` to
#' \link[lpjmlkit]{write_config}
#'
#' | **sim_name**    | **dependency** |
#' |:--------------- | :------------- |
#' | scen1_spinup    | NA             |
#' | scen2_transient | scen1 _spinup  |
#'
#' To use different slurm settings for each run the optional slurm options
#' `"sclass"`, `"ntask"`, `"wtime"` or `"blocking"` can also be supplied to the
#' initial \link[tibble]{tibble} supplied as `param` to
#' \link[lpjmlkit]{write_config} which then overwrite the (default) slurm
#' arguments (`sclass`, `ntask`, `wtime` or `blocking`) supplied to
#' `submit_lpjml`.
#'
#' | **sim_name**    | **dependency** | **wtime** |
#' |:--------------- |:-------------- |----------:|
#' | scen1_spinup    | NA             | "8:00:00" |
#' | scen2_transient | scen1 _spinup  | "2:00:00" |
#'
#' As a shortcut it is also possible to provide the config file
#' `"config_*.json"` as a character string or multiple config files as a
#' character string vector directly as `x` to `submit_lpjml`. \cr
#' Of course run parameters or slurm options cannot be taken into account in
#' this approach. \cr
#'
#' @examples
#'
#' \dontrun{
#' library(lpjmlkit)
#' library(tibble)
#'
#' model_path <- "./LPJmL_internal"
#' output_path <-"./my_runs"
#'
#'
#' # basic usage
#' my_params <- tibble(
#'  sim_name = c("scen1", "scen2"),
#'  random_seed = as.integer(c(42, 404)),
#'  pftpar.1.name = c("first_tree", NA),
#'  param.k_temp = c(NA, 0.03),
#'  new_phenology = c(TRUE, FALSE)
#' )
#'
#' config_details <- write_config(my_params, model_path, output_path)
#'
#'  run_details <- submit_lpjml(
#'   x = config_details,
#'   model_path = model_path,
#'   output_path = output_path
#' )
#'
#' run_details
#' #   sim_name      job_id   status
#' #   <chr>           <int>  <chr>
#' # 1 scen1        21235215  submitted
#' # 2 scen2        21235216  submitted
#'
#'
#' # with run parameter dependency and slurm option wtime being
#' #   set (also less other parameters than in previous example)
#' my_params <- tibble(
#'   sim_name = c("scen1", "scen2"),
#'   random_seed = as.integer(c(42, 404)),
#'   dependency = c(NA, "scen1_spinup"),
#'   wtime = c("8:00:00", "4:00:00"),
#' )
#'
#' config_details2 <- write_config(my_params2, model_path, output_path)
#'
#' run_details2 <- submit_lpjml(config_details2, model_path, output_path)
#'
#' run_details2
#' #   sim_name        order dependency   wtime   type       job_id   status
#' #   <chr>           <dbl> <chr>        <chr>   <chr>      <chr>    <chr>
#' # 1 scen1_spinup        1 NA           8:00:00 simulation 22910240 submitted
#' # 2 scen1_transient     2 scen1_spinup 4:00:00 simulation 22910241 submitted
#'
#'
#' # same but by using the pipe operator
#' run_details <- tibble(
#'   sim_name = c("scen1_spinup", "scen1_transient"),
#'   random_seed = as.integer(c(1, 42)),
#'   dependency = c(NA, "scen1_spinup"),
#'   wtime = c("8:00:00", "4:00:00"),
#' ) %>%
#'   write_config(model_path, output_path) %>%
#'   submit_lpjml(model_path, output_path)
#'
#'
#' # shortcut approaches
#' run_details <- submit_lpjml(
#'   x = "./config_scen1_transient.json",
#'   model_path = model_path,
#'   output_path = output_path
#' )
#'
#' run_details <- submit_lpjml(
#'   c("./config_scen1_spinup.json", "./config_scen1_transient.json"),
#'   model_path,
#'   output_path
#' )
#'
#' }
#'
#' @md
#' @export
submit_lpjml <- function(x, # nolint:cyclocomp_linter.
                         model_path,
                         output_path = NULL,
                         group = "lpjml",
                         sclass = "short",
                         ntasks = 256,
                         wtime = "",
                         blocking = "",
                         no_submit = FALSE) {

  # check if slurm is available
  if (!is_slurm_available() && !no_submit) {
    stop("submit_lpjml is only available on HPC cluster environments providing
          a SLURM workload manager")
  }

  # check if model_path is set or unit test flag provided
  if (!dir.exists(model_path)) {
    if (model_path != "TEST/PATH") {
      stop(
        paste0("Folder of model_path \"", model_path, "\" does not exist!")
      )
    }
  }

  if (is.null(output_path)) output_path <- model_path

  # case if character vector with file names is supplied instead of tibble
  if (methods::is(x, "character")) {
    x <- tibble::tibble(sim_name = sapply( # nolint:undesirable_function_linter.
      x,
      function(x) {
        strsplit(
          strsplit(rev(strsplit(x, "/")[[1]])[1], "config_")[[1]][2],
          ".json"
        )[[1]]
      }
    ))
  }

  x$type <- "simulation"
  x$job_id <- NA
  x$status <- "failed"
  slurm_args <- c("sclass", "ntask", "wtime", "blocking")

  if ("order" %in% colnames(x)) {

    for (order in unique(sort(x$order))) {
      sim_names <- x$sim_name[
        which(x$order == order)
      ]

      for (sim_name in sim_names) {

        sim_idx <- which(x$sim_name == sim_name)

        # get dependency by sim_id
        dependency <- ifelse(!is.na(x$dependency[sim_idx]),
                             x$job_id[x$sim_name == x$dependency[sim_idx]],
                             NA)

        # extract slurm arguments and overwrite functions slurm arguments by
        #   mapply call
        slurm_param <- (
          x[slurm_args[slurm_args %in% colnames(x)]][
              sim_idx, ]
        )

        mapply( # nolint:undesirable_function_linter.
          function(x, xn) {
            if (!is.na(x)) {
              assign(xn, x, envir = parent.frame(n = 2))
            }
          },
          x = slurm_param,
          xn = colnames(slurm_param)
        )

        # no submit option for testing
        if (!no_submit) {
          job <- submit_run(sim_name,
                            model_path,
                            output_path,
                            group,
                            sclass,
                            ntasks,
                            wtime,
                            blocking,
                            dependency)

          if (job$status == 0) {
            x$job_id[sim_idx] <- strsplit(
              strsplit(job$stdout, "Submitted batch job ")[[1]][2], "\n"
            )[[1]][1]

            x$status[sim_idx] <- "submitted"
          }

        } else {
          x$job_id[sim_idx] <- NA
          x$status[sim_idx] <- "not submitted"
        }
      }
    }

  } else {

    for (sim_name in x$sim_name) {

      sim_idx <- which(x$sim_name == sim_name)

      # extract slurm arguments and overwrite functions slurm arguments by
      #   mapply call
      slurm_param <- (
        x[slurm_args[slurm_args %in% colnames(x)]][
            sim_idx, ]
      )

      mapply( # nolint:undesirable_function_linter.
        function(x, xn) {
          if (!is.na(x)) {
            assign(xn, x, envir = parent.frame(n = 2))
          }
        },
        x = slurm_param,
        xn = colnames(slurm_param)
      )

      if (!no_submit) {
        job <- submit_run(sim_name,
                          model_path,
                          output_path,
                          group,
                          sclass,
                          ntasks,
                          wtime,
                          blocking,
                          dependency = NA)

        if (job$status == 0) {
          x$job_id[sim_idx] <- strsplit(
            strsplit(job$stdout, "Submitted batch job ")[[1]][2], "\n"
          )[[1]][1]

          x$status[sim_idx] <- "submitted"

        } else {
          x$status[sim_idx] <- "failed"
        }

      } else {
        x$job_id[sim_idx] <- NA
        x$status[sim_idx] <- "not submitted"
      }
    }
  }

  attr(x, "stages") <- append(attr(x, "stages"), "lpjml")
  return(x)
}


# internal submit run function
submit_run <- function(sim_name,
                       model_path,
                       output_path,
                       group,
                       sclass,
                       ntasks,
                       wtime,
                       blocking,
                       dependency) {

  config_file <- paste0("config_",
                        sim_name,
                        ".json")

  timestamp <- format(Sys.time(), "%Y%m%d_%H%M")

  stdout <- paste0(output_path,
                  "/output/",
                  sim_name,
                  "/",
                  "outfile_",
                  timestamp,
                  ".out")

  stderr <- paste0(output_path,
                  "/output/",
                  sim_name,
                  "/",
                  "errfile_",
                  timestamp,
                  ".err")

  output_config <- paste0(output_path,
                  "/output/",
                  sim_name,
                  "/",
                  "config_",
                  timestamp,
                  ".json")

  inner_command <-  paste0(model_path, "/bin/lpjsubmit", # nolint:absolute_path_linter.
                           " -nocheck",
                           " -class ", sclass,
                           " -group ", group,
                           ifelse(wtime != "",
                                  paste0(" -wtime ", wtime),
                                  ""),
                           ifelse(blocking != "",
                                  paste0(" -blocking ", blocking),
                                  ""),
                           ifelse(!is.na(dependency),
                                  paste0(" -dependency ", dependency),
                                  ""),
                           " -o ", stdout,
                           " -e ", stderr,
                           " ",
                           ntasks,
                           " ",
                           output_path,
                           "/configurations/",
                           config_file)

  # get LPJROOT variable and set according to model_path
  pre_lpjroot <- Sys.getenv("LPJROOT")

  # tryCatch to be able to set it back to its original value in case sth fails
  tryCatch({

    Sys.setenv(LPJROOT = model_path) # nolint:undesirable_function_linter.

    # run lpjsubmit
    submit_status <- processx::run(command = "sh",
                                   args = c("-c", inner_command),
                                   cleanup_tree = TRUE)

    copied <- file.copy(from = paste(output_path, # nolint:object_usage_linter.
                                     "configurations",
                                     config_file,
                                     sep = "/"),
                        to = output_config)

  }, finally = {

    if (pre_lpjroot == "") {

      # "" meaning it was not defined before thus unset
      Sys.unsetenv("LPJROOT") # nolint:undesirable_function_linter.
    } else {

      # set back to its original value
      Sys.setenv(LPJROOT = pre_lpjroot) # nolint:undesirable_function_linter.
    }
  })

  return(submit_status)
}


# function to check if slurm is available - if so return TRUE
is_slurm_available <- function() {
  processx::run(command = "sh",
                args = c("-c", "sinfo"),
                error_on_status = FALSE) %>%
  .$status == 0 %>%
    return()
}
