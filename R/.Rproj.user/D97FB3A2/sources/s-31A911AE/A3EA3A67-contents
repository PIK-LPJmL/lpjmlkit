Sys.setlocale('LC_ALL','C')
### ================ global variable definitions ============
ncells=67420
ndays=c(31,28,31,30,31,30,31,31,30,31,30,31)

### ================ read routines ===================

#' Reads daily netcdf and returns it as LPJ-array
#'
#' Reads a daily netcdf and returns the values at the LPJ-grid locations
#' the netcdf resolution needs to correspond to the LPJmL grid resolution 
#' (i.e. the LPJ cells need to have the same center coordinates than the netcdf)
#'
#' @param ncInFile netcdf file name
#' @param var netcdf variable name
#' @param years total years stored in netcdf file
#' @param lon array with longitude coordinates of the centers of the LPJmL grid
#' @param lat array with latitude coordinates of the centers of the LPJmL grid
#'
#' @return lpjml array with data from netcdf, dim=c(ncells,days,years)
#'
#' @examples
#' \dontrun{
#' netcdfDaily2lpjarray(ncInFile=ddischarge_1901-2005.nc4,var="dis",years=105,lon=lon,lat=lat)
#' }
#'
#' @export
netcdfDaily2lpjarray <- function(ncInFile,var,years,lon,lat){
  require(raster)
  require(ncdf4)
  # NetCDF file
  file_nc <- nc_open(ncInFile)
  # get spatial extent and resolution
  # this will give a warning if the NetCDF has more than one data field, e.g. crop bands or time axis
  file_raster <- raster(ncInFile)
  cells=cellFromXY(file_raster, cbind(lon,lat))
  time=ncvar_get(file_nc,"time")
  days=length(time)/years
  if (!days==round(days)) print("Potential error in number of days - check leap days?")
  outdata=array(0,dim=c(length(lon),days,years))
  # loop over individual days and years in NetCDF
  for (year in 1:years){
    for (day in 1:days){
      # this assumes a 3-dimensional array: lon, lat, time
      data <- ncvar_get(file_nc, var, start=c(1,1, year*(year-1)+day), count=c(-1,-1,1))
      # check whether data needs to be flipped vertically
      # lat axes in NetCDF files can be from north to south or from south to north
      if((yFromRow(file_raster, 1)<yFromRow(file_raster, 2)) != (file_nc$dim$lat$vals[1]<file_nc$dim$lat$vals[2])) {
        # flip vertically
        data <- data[, file_nc$dim$lat$len:1,]
      }
      # dissolve lon and lat dimensions into one
      dim(data) <- c(file_nc$dim$lat$len*file_nc$dim$lon$len)
      # extract data for LPJmL coordinates using cellFromXY()
      # resulting array has dimensions c(ncell, nbands)
      outdata[,day,year] <- data[cells]
    }
  }
  nc_close(file_nc)
  return(outdata)
}

#' Reads monthly netcdf and returns it as LPJ-array
#'
#' Reads a monthly netcdf and returns the values at the LPJ-grid locations
#' the netcdf resolution needs to correspond to the LPJmL grid resolution 
#' (i.e. the LPJ cells need to have the same center coordinates than the netcdf)
#'
#' @param ncInFile netcdf file name
#' @param var netcdf variable name
#' @param lon array with longitude coordinates of the centers of the LPJmL grid
#' @param lat array with latitude coordinates of the centers of the LPJmL grid
#'
#' @return lpjml array with data from netcdf, dim=c(ncells,months,years)
#'
#' @examples
#' \dontrun{
#' netcdfMonthly2lpjarray(ncInFile=mdischarge_1901-2005.nc4,var="dis",years=105,lon=lon,lat=lat)
#' }
#'
#' @export
netcdfMonthly2lpjarray <- function(ncInFile,var,lon,lat){
  require(raster)
  require(ncdf4)
  # NetCDF file
  file_nc <- nc_open(ncInFile)
  # get spatial extent and resolution
  # this will give a warning if the NetCDF has more than one data field, e.g. crop bands or time axis
  file_raster <- raster(ncInFile)
  cells=cellFromXY(file_raster, cbind(lon,lat))
  time=ncvar_get(file_nc,"time")
  years=length(time)/12
  outdata=array(0,dim=c(length(lon),12,years))
  # loop over individual days and years in NetCDF
  for (year in 1:years){
    for (month in 1:12){
      # this assumes a 3-dimensional array: lon, lat, time
      data <- ncvar_get(file_nc, var, start=c(1,1, (year-1)*12+month), count=c(-1,-1,1))
      # check whether data needs to be flipped vertically
      # lat axes in NetCDF files can be from north to south or from south to north
      if((yFromRow(file_raster, 1)<yFromRow(file_raster, 2)) != (file_nc$dim$lat$vals[1]<file_nc$dim$lat$vals[2])) {
        # flip vertically
        data <- data[, file_nc$dim$lat$len:1,]
      }
      # dissolve lon and lat dimensions into one
      dim(data) <- c(file_nc$dim$lat$len*file_nc$dim$lon$len)
      # extract data for LPJmL coordinates using cellFromXY()
      # resulting array has dimensions c(ncell, nbands)
      outdata[,month,year] <- data[cells]
    }
  }
  nc_close(file_nc)
  return(outdata)
}

#' Reads a header from an LPJ input file
#'
#' tries to determine header version unless force_version is provided
#' return value: list with 3 components:                              ##
#' - header name, e.g. LPJGRID                                        ##
#' - header values (11 in total), if header version is <3, partially  ##
#'   filled with default values                                       ##
#' - endian of file (little or big)
#'
#' @param filename filename to read header from
#' @param force_version force clm version (default NULL - no)
#' @param endian endianness (default copied from local platform -- .Platform$endian)
#'
#' @return list-object with header content
#'
#' @examples
#' \dontrun{
#' readheader(filename, force_version=NULL)
#' }
#'
#' @export
readheader <- function(filename, force_version=NULL,endian=.Platform$endian) {
  if(!file.exists(filename)) {
    stop(paste("Error in readheader:", filename, "does not exist"))
  }
  zz <- file(filename, "rb")
  headername <- rawToChar(readBin(zz, raw(), n=30), multiple=TRUE)
  headername <- headername[1:(min(which(!grepl("[[:alpha:]_]", headername)))-1)]
  headername <- paste(headername, collapse="")
  if(substr(headername, 1,3) != "LPJ") {
    close(zz)
    stop(paste("Error in readheader: invalid header name", headername))
  }
  seek(zz, nchar(headername))
  endian <- .Platform$endian
  version <- readBin(zz, integer(), size=4, n=1, endian=endian)
  if(bitwAnd(version, 0xff)==0) {
    endian <- ifelse(endian=="little", "big", "little")
    seek(zz, nchar(headername))
    version <- readBin(zz, integer(), size=4, n=1, endian=endian)
  }
  if(!is.null(force_version)) {
    print(paste("Forcing header version to", force_version))
    version <- force_version
  }
  headerdata <- readBin(zz, integer(), size=4, n=6, endian=endian)
  names(headerdata) <- c("order", "firstyear", "nyear", "firstcell", "ncell", "nbands")
  if(version == 2) {
    headerdata <- c(headerdata, readBin(zz, double(), size=4, n=2, endian=endian))
    names(headerdata) <- c(names(headerdata[1:6]), "cellsize_lon", "scalar")
  }
  if(version == 3) {
    headerdata <- c(headerdata, readBin(zz, double(), size=4, n=3, endian=endian))
    headerdata <- c(headerdata, readBin(zz, integer(), size=4, n=1, endian=endian))
    names(headerdata) <- c(names(headerdata[1:(length(headerdata)-4)]), "cellsize_lon", "scalar", "cellsize_lat", "datatype")
  } else {
    if(length(headerdata)==6) {
      headerdata <- c(headerdata, cellsize_lon=0.5, scalar=1, cellsize_lat=0.5, datatype=1)
      warning("Type 1 header. Adding default values for cellsize, scalar and datatype which may not be correct in all cases")
    }
    if(length(headerdata)==8) {
      headerdata <- c(headerdata, cellsize_lat=as.double(headerdata["cellsize_lon"]), datatype=1)
      warning("Type 2 header. Adding default value for datatype which may not be correct in all cases")
    }
  }
  close(zz)
  return(list(name=headername, header=c(version=version, headerdata), endian=endian))
}

#' Automatically reads LPJmL input including header
#'
#' most header variables will be automatically read
#' for some combinations this won't work, thus
#' a manual override switch can be used to set size  
#' 
#' @param inFile name of file to read
#' @param getyearstart first year to be read (if not specified will default to startyear from header)
#' @param getyearstop final year to be read (if not specified will default to stopyear from header)
#' @param manu switch to allow for manual override of size (default False)
#' @param msize manual size, only applied if manu==TRUE (default 4)
#' @param mheadersize manual header size, only applied if manu==TRUE (default 43)
#'
#' @return data array
#'
#' @examples
#' \dontrun{
#' autoReadInput(inFile,getyearstart=-1,getyearstop=-1,manu=T,msize=2,mheadersize=0)
#' }
#'
#' @export
autoReadInput <- function(inFile,getyearstart=-1,getyearstop=-1,manu=F,msize=4,mheadersize=43){
  hdr=readheader(filename=inFile)$header
  print(hdr)
  startyear=hdr[3]
  stopyear=hdr[3]+hdr[4]-1
  ncells=hdr[6]
  nbands=hdr[7]
  if (getyearstart==-1){
    getyearstart=startyear
  }
  if (getyearstop==-1){
    getyearstop=stopyear
  }
  if (hdr[1]==1){#header version 1 
    headersize=36
  }else if (hdr[1]==2){#header version 2
    headersize=43
  }else{ #header version 3
    headersize=51
  }
  if (length(hdr)>10){
    if (hdr[11]==0){
      size=1
      inputType="char"
    }else if(hdr[11]==1){
      size=2
      inputType="integer"
    }else if(hdr[11]==2){
      size=4
      inputType="integer"
    }else if(hdr[11]==3){
      size=4
      inputType="double"
    }else if(hdr[11]==4){
      size=8
      inputType="double"
    }
  }
  if (manu){
    size=msize
    headersize=mheadersize
  }
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*ncells*size*nbands, origin="start")
  if (inputType == "integer"){
    dataIn <- readBin(input,integer(),n = nyears*ncells*nbands, size=size)
  }else if (inputType == "double"){
    dataIn <- readBin(input,double(),n = nyears*ncells*nbands, size=size)
  }else{
    dataIn <- readBin(input,character(),n = nyears*ncells*nbands, size=size)
  }
  close(input)      #remove to save space
  print(paste("nyears=",nyears," nbands=",nbands," ncells=",ncells," size=",size," headersize=",headersize))
  if (nyears==1){
    dim(dataIn) <- c(nbands,ncells)
  }else{
    dim(dataIn) <- c(nbands,ncells,nyears)
  }
  return(dataIn*hdr[["scalar"]])
}

#' Transform even grid to lpjml grid
#'
#' Transform even grid (e.g. from a netcdf) to lpjml grid
#'
#' @param gridIn even grid to be transformed (e.g. c(720,360) for 0.5 deg)
#' @param lonIn longitude vector of input grid
#' @param latIn latitude vector of input grid
#' @param ncells number of lpj cells (default is 67420 for 30min res), 2298847 for 5min res
#' @param res resolution (default 0.5)
#'
#' @return outlist transformed data in lpjml format
#'
#' @examples
#' evenGrid2lpjGrid(gridIn=climateCategories,lonIn=seq(-179.75,179.75,0.5),latIn=seq(-89.75,89.75,0.5))
#'
#' @export
evenGrid2lpjGrid <- function(gridIn,lonIn,latIn,ncells=67420,res=0.5){
  l=length(dim(gridIn))
  if (l==2){
    outlist <- array(0,dim=c(ncells))
  }else if(l==3){
    outlist <- array(0,dim=c(ncells,length(gridIn[1,1,])))
  }
  if (l==2){
    for (i in 1:ncells){
      outlist[i] <- gridIn[which(round(lonIn,2)==lon[i]),which(round(latIn,2)==lat[i])] # minus lat[i] only if the grid is flipped in lat
    }
  }else if (l==3){
    for (y in c(1:length(gridIn[1,1,])) ){
      for (i in 1:ncells){
        outlist[i,y] <- gridIn[which(round(lonIn,2)==lon[i]),which(round(latIn,2)==lat[i]),y] # minus lat[i] only if the grid is flipped in lat
      }
    }  
  }
  return(outlist)
}


#' Get header of LPJmL input file
#'
#' Reads the header of a binary CLM(2) LPJmL input file and returns the content as data_frame
#'
#' @param f.in file connection to read the header from
#'
#' @return data_frame of header data
#'     h$v : header version,
#'     h$o : order,
#'     h$fy : firstyear,
#'     h$ny : nyear,
#'     h$fc : firstcell,
#'     h$nc : ncells,
#'     h$nb : nbands,
#'     h$r : resolution,
#'     h$b : scaling
#'
#' @examples
#' freadheader(system.file("extdata", "grid.bin", package = "lpjmliotools", mustWork = TRUE))
#'
#' @export
freadheader <- function(f.in){
  h <- list()
  h$name <- readChar(f.in, 7)                  # header name
  #h$name <- readBin(f.in,character(), size=8)   # header name
  h$v <- readBin(f.in, integer(), n=1, size=4) # header version
  h$o <- readBin(f.in, integer(), n=1, size=4) # order
  h$fy <- readBin(f.in,integer(), n=1, size=4) # firstyear
  h$ny <- readBin(f.in,integer(), n=1, size=4) # nyear
  h$fc <- readBin(f.in, integer(),n=1,size=4)  # firstcell
  h$nc <- readBin(f.in,integer(),n=1,size=4)   # ncells
  h$nb <- readBin(f.in,integer(),n=1,size=4)   # nbands
  h$r <- readBin(f.in,double(),n=1, size=4)    # resolution
  h$b <- readBin(f.in,double(),n=1, size=4)    # scaling
  return(h)
}

#' Get country code list
#'
#' Reads and returns the list of country codes contained in
#'
#' @param fileName character string containing the file to read the cow from ()
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of 2 IDs (countrycode,regioncode) for each of the 67420 gridcells
#'
#' @examples
#' lpjCOW(system.file("extdata", "cow_mg_2006.bin", package = "lpjmliotools", mustWork = TRUE))
#'
#' @export
lpjCOW <- function(fileName,ncells=67420){
  zz    <- file(fileName,"rb")
  seek(zz, where = 43, origin="start")
  cow <- readBin(zz, integer(), 2*ncells, size=2)
  dim(cow)=c(2,ncells)
  close(zz)
  return(cow)
}

#' Read monthly LPJmL output file
#'
#' Returns a range of years from a monthly LPJmL output of dimension c(ncells,12,nyears)
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param size size of each cell's data (2 or 4 bytes)
#' @param headersize size of header data (defaults to 0 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of monthly data c(ncells,12,nyears) for each of the 67420 gridcells over requested range of years
#'
#' @examples
#' \dontrun{
#' readMonthly(inFile="mwateramount.bin",startyear=1861,stopyear=2005,size=4,headersize=0,
#'             getyearstart=1984,getyearstop=2005)
#' }
#'
#' @export
readMonthly <- function(inFile,startyear,stopyear,size,headersize=0,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*12*ncells*size, origin="start")
  monthly <- readBin(input,double(),n = nyears*ncells*12, size=size)
  close(input)      #remove to save space
  if (nyears==1){
    dim(monthly) <- c(ncells,12)
  }else{
    dim(monthly) <- c(ncells,12,nyears)
  }
  return(monthly)
}

#' Read yearly LPJmL input file
#'
#' Returns a range of years from a LPJmL input of dimension c(ncells,nyears)
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param size size of each cell's data (2 or 4 bytes)
#' @param inputType type of variable to read, integer/double
#' @param headersize size of header data (defaults to 43 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of data c(ncells,nyears) for each of the 67420 gridcells over requested range of years
#'
#' @examples
#' \dontrun{
#' readYearlyInput(inFile="wateruse_1900_2005.bin",startyear=1900,stopyear=2005,size=4,headersize=43,
#'            getyearstart=1984,getyearstop=2005)
#' }
#'
#' @export
readYearlyInput <- function(inFile,startyear,stopyear,size,inputType,headersize=43,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*ncells*size, origin="start")
  if (inputType == "integer"){
    dataIn <- readBin(input,integer(),n = nyears*ncells, size=size)
  }else if (inputType == "double"){
    dataIn <- readBin(input,double(),n = nyears*ncells, size=size)
  }else{
    print("unknown input type")
  }
  close(input)      #remove to save space
  if (nyears==1){
    dim(dataIn) <- c(ncells)
  }else{
    dim(dataIn) <- c(ncells,nyears)
  }
  return(dataIn)
}

#' Read daily LPJmL output file
#'
#' Returns a range of years from a daily LPJmL output of dimension c(ncells,365,nyears)
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param size size of each cell's data (2 or 4 bytes)
#' @param headersize size of header data (defaults to 0 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of daily data c(ncells,365,nyears) for each of the 67420 gridcells over requested range of years
#'
#' @examples
#' \dontrun{
#' readDaily(inFile="mwateramount.bin",startyear=1861,stopyear=2005,size=4,headersize=0,
#'             getyearstart=1984,getyearstop=2005)
#' }
#'
#' @export
readDaily <- function(inFile,startyear,stopyear,size,headersize=0,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*365*ncells*size, origin="start")
  daily <- readBin(input,double(),n = nyears*ncells*365, size=size)
  close(input)      #remove to save space
  if (nyears==1){
    dim(daily) <- c(ncells,365)
  }else{
    dim(daily) <- c(ncells,365,nyears)
  }
  return(daily)
}

#' Read yearly LPJmL output file
#'
#' Returns a range of years from a LPJmL output of dimension c(ncells,nyears)
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param size size of each cell's data (2 or 4 bytes)
#' @param headersize size of header data (defaults to 0 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of data c(ncells,nyears) for each of the 67420 gridcells over requested range of years
#'
#' @examples
#' \dontrun{
#' readYearly(inFile="hdates.bin",startyear=1901,stopyear=2005,size=2,headersize=0,
#'            getyearstart=1984,getyearstop=2005)
#' }
#'
#' @export
readYearly <- function(inFile,startyear,stopyear,size,headersize=0,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*ncells*size, origin="start")
  if (size==2){
    dataIn <- readBin(input,integer(),n = nyears*ncells, size=size)
  }else if (size==4){
    dataIn <- readBin(input,double(),n = nyears*ncells, size=size)
  }else{
    print("unknown data size")
  }
  close(input)      #remove to save space
  if (nyears==1){
    dim(dataIn) <- c(ncells)
  }else{
    dim(dataIn) <- c(ncells,nyears)
  }
  return(dataIn)
}

#' Read cft LPJmL output
#'
#' Returns a range of years from a cft LPJmL output of dimension c(ncells,bands,nyears).
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param bands number of bands (32 for standard LPJmL output, 64 for standard input)
#' @param size size of each cell's data (2 or 4 bytes)
#' @param headersize size of header data (defaults to 0 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of data c(ncells,bands,nyears) for each of the 67420 gridcells over requested range of years or c(ncells,bands) for one year
#
#' @examples
#' \dontrun{
#' readCFToutput(inFile="cftfrac.bin",startyear=1861,stopyear=2005,bands=32,size=4,headersize=0,
#'         getyearstart=2005,getyearstop=2005,ncells=67420)
#' }
#' 
#' @export
readCFToutput <- function(inFile,startyear,stopyear,bands,size,headersize,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = headersize+(getyearstart-startyear)*bands*ncells*size, origin="start")
  if (size==2){
    cftfracs <- readBin(input,integer(),n = nyears*ncells*bands, size=size)
  }else if (size==4){
    cftfracs <- readBin(input,double(),n = nyears*ncells*bands, size=size)
  }else{
    print("unknown data size")
  }
  close(input)
  if (nyears==1){
    dim(cftfracs) <- c(ncells,bands)
  }else{
    dim(cftfracs) <- c(ncells,bands,nyears)
  }
  return(cftfracs)
}

#' Read cft LPJmL input
#'
#' Returns a range of years from a cft LPJmL input of dimension c(ncells,bands,nyears).
#'
#' @param inFile character string containing the file to read the data from
#' @param startyear absolute startyear of output
#' @param stopyear absolute stopyear of output
#' @param bands number of cft-bands (32 for standard LPJmL input, 64 for standard input)
#' @param size size of each cell's data (2 or 4 bytes)
#' @param headersize size of header data (defaults to 43 bytes)
#' @param getyearstart start of range to return
#' @param getyearstop end of range to return
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return array of cft-fractions c(bands,ncells,nyears) for each of the 67420 gridcells over requested range of years
#
#' @examples
#' \dontrun{
#' readCFTinput(inFile="cftinput.bin",startyear=1901,stopyear=2015,bands=64,size=4,headersize=43,
#'         getyearstart=2005,getyearstop=2005)
#' }
#' 
#' @export
readCFTinput <- function(inFile,startyear,stopyear,bands,size,dtype,headersize=43,getyearstart,getyearstop,ncells=67420){
  if (getyearstop>stopyear){
    stop(paste("unexpected usage: getyearstop (",getyearstop,") larger than stopyear (",stopyear,") -- stopping"))
  }
  if (getyearstart<startyear){
    stop(paste("unexpected usage: getyearstart (",getyearstart,") smaller than startyear (",startyear,") -- stopping"))
  }
  nyears=getyearstop-getyearstart+1
  input <- file(inFile,"rb")
  seek(input, where = (getyearstart-startyear)*bands*ncells*size+headersize, origin="start")
  if (dtype=="integer"){
      cftfracs <- readBin(input,integer(),n = nyears*ncells*bands, size=size)
  }else if (dtype=="double"){
      cftfracs <- readBin(input,double(),n = nyears*ncells*bands, size=size)
  }else{
    print("unknown data type")
  }
  close(input)
  if (nyears==1){
    dim(cftfracs) <- c(bands,ncells)
  }else{
    dim(cftfracs) <- c(bands,ncells,nyears)
  }
  return(cftfracs)
}

### ================ write routines ===================

#' write a header to a file
#'
#' expects a list following the structure returned by readheader() or
#' new_header()
#' will fail if output file exists, unless overwrite set to TRUE
#'
#' @param filename filename to write header into
#' @param header header list
#' @param overwrite overwrites output file if exists (default FALSE) 
#'
#' @return None
#'
#' @examples
#' \dontrun{
#' writeheader(filename="filename.clm", header=header, overwrite=FALSE)
#' }
#'
#' @export
writeheader <- function(filename, header, overwrite=FALSE) {
  if(!is.list(header)) stop("Error: header must be a list() object")
  if(is.null(header[["name"]]) || is.null(header[["header"]]) || is.null(header[["endian"]])) stop("Error: header must have elements name, header and endian")
  if(file.exists(filename)) {
    if(!overwrite) stop(paste("Error:", filename, "exists already. Set overwrite to TRUE if you want to force it to be overwritten"))
    print(paste("Warning:", filename, "exists already and will be overwritten."))
  }
  zz <- file(filename, "wb")
  writeBin(charToRaw(header$name), zz)
  writeBin(as.integer(header$header[c("version", "order", "firstyear", "nyear", "firstcell", "ncell", "nbands")]), zz, size=4, endian=header$endian)
  if(header$header["version"] > 1) {
    writeBin(as.double(header$header[c("cellsize_lon", "scalar")]), zz, size=4, endian=header$endian)
  }
  if(header$header["version"] > 2) {
    writeBin(as.double(header$header["cellsize_lat"]), zz, size=4, endian=header$endian)
    writeBin(as.integer(header$header["datatype"]), zz, size=4, endian=header$endian)
  }
  close(zz)
}

#' Write header of LPJmL input file
#' 
#' Writes the header of a binary CLM(2) LPJmL input file
#' into an open file connection
#' 
#' @param file.out file connection to the file to append the header to  
#' @param headername character string containing the name of the header 
#' @param version CLM Version (default is 2)
#' @param firstyear first year of data set 
#' @param lastyear last year covered in the data set
#' @param bands number of cft-bands (32 or 64 for standard input)
#' @param scalar for cft fracs set to 0.001
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#' 
#' @return None
#' 
#' @examples
#' \dontrun{
#' fwriteheader(file.out=cftfracs_file,headername="LPJLUSE",version=2, firstyear = 2006,lastyear = 2100, bands=64, scalar=0.001)
#' }
#' 
#' @export
fwriteheader <- function(file.out,headername,version=2,firstyear,lastyear,bands,scalar,ncells=67420){
  nyears=lastyear-firstyear+1
  writeChar(headername,file.out,eos=NULL)
  writeBin(as.integer(version),file.out,size=4,endian=.Platform$endian)   # CLIMATE VERSION
  writeBin(as.integer(1),file.out,size=4,endian=.Platform$endian)       # ORDER
  writeBin(as.integer(firstyear),file.out,size=4,endian=.Platform$endian) # FIRSTYEAR
  writeBin(as.integer(nyears),file.out,size=4,endian=.Platform$endian)       # NYEAR
  writeBin(as.integer(0),file.out,size=4,endian=.Platform$endian)       # FIRSTCELL
  writeBin(as.integer(ncells),file.out,size=4,endian=.Platform$endian)       # NCELL
  writeBin(as.integer(bands),file.out,size=4,endian=.Platform$endian)       # NBAND
  writeBin(0.5,file.out,size=4,endian=.Platform$endian)               # CELLSIZE
  writeBin(scalar,file.out,size=4,endian=.Platform$endian)               # SCALAR
}


#' Write cft LPJmL input file
#' 
#' Writes a binary CLM(2) LPJmL input file with header from an array of dimension c(ncells,bands,nyears) 
#' and checks whether the sums of all cft fracs per grid cell are always <= 1000. 
#' 
#' @param filename character string containing the name of the file to write the cft input in
#' @param input_array array of dimension c(ncells,bands,nyears)
#' @param firstyear first year in array
#' @param lastyear last year in array 
#' @param bands number of cft-bands (32 or 64 for standard input) 
#' 
#' @return boolean containing TRUE (the sums of all cft fracs per grid cell are always equal or below 1000) or FALSE (the sums of all cft fracs per grid cell are not always equal or below 1000)
#' 
#' @examples
#' \dontrun{
#' writeCFTinput(filename="cftfrac_rcp26_2006-2100_64bands.clm", input_array = CFT_2006_2100, firstyear=2006,lastyear=2100,bands=64)
#' }
#' 
writeCFTinput <- function(filename, input_array, firstyear, lastyear, bands){
  nyears=lastyear-firstyear+1
  #check if sum of lu shares in array always <= 1000
  lutotal<-apply(input_array,c(2,3),sum)
  check<-FALSE
  range<-range(lutotal)
  if (range[2]<=1000){check[1]<-TRUE}
  print("LU share sums always equal to or below 1000?");print(check)
  # open file for binary writing 
  f.out<- file(filename,"wb")   
  # write header
  fwriteheader(f.out,"LPJLUSE",2, firstyear,nyears, bands, 0.001)
  # write data
  for (i in firstyear:lastyear){
    writeBin(as.integer(as.vector(input_array[,,i-firstyear+1])),f.out,size=2)
  } 
  close(f.out)
}

#' Write wateruse LPJmL input file
#' 
#' Writes a binary CLM(2) LPJmL input file with header from an array of dimension c(ncells,bands,nyears) 
#' 
#' @param filename character string containing the name of the file to write the cft input in
#' @param input_array array of dimension c(ncells,bands,nyears) or c(ncells,nyears)
#' @param firstyear first year in array
#' @param lastyear last year in array 
#' @param bands number of cft-bands (32 or 64 for standard input) 
#' @param out_name LPJmL variable to write out e.g. "LPJLUSE" oder "LPJWUSE"
#' @param out_size size of integer to be writte out (2/4)
#' @param out_scaling optional scaling factor to be applied, defaults to 1
#' 
#' @examples
#' \dontrun{
#' writeWUinput(filename="wateruse_wd_2band_2006_2050.clm", input_array = waterinput, firstyear=2006, lastyear=2050, bands=2, out_name="LPJWUSE", out_size=4, out_scaling=1)
#' }
#' 
writeWUinput <- function(filename, input_array, fromyear, toyear, out_bands, out_name, out_size, out_scaling=1){
  ncells=dim(input_array)[1]
  # open file for binary writing 
  f.out<- file(filename,"wb")
  # write header
  print(paste("Writing Header to: ",filename, out_name, 2, fromyear, toyear, out_bands, out_scaling))
  
  fwriteheader(file.out = f.out, headername = out_name, version = 2, firstyear = fromyear, lastyear = toyear, bands = out_bands, scalar = out_scaling)
  # write data
  for (i in fromyear:toyear){
    if (out_bands==1){
      writeBin(as.integer(as.vector(input_array[,i-fromyear+1]*1/out_scaling)),f.out,size=out_size)
    }else{
      for (c in 1:ncells){
        writeBin(as.integer(as.vector(input_array[c,,i-fromyear+1]*1/out_scaling)),f.out,size=out_size)
      }
    }
  } 
  close(f.out)
}

### ================ plotting routines ===================

#' Plot global LPJmL data with manual breaks and colorramp
#'
#' Creates a PNG/eps plot of a global LPJmL array dim=c(67420) with manual 
#' breaks and a custom colorramp (if manual colorramp is not provided, YlGnBu is used) 
#'
#' @param data LPJmL specific array c(67420) to be plotted
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param brks array with breaks to be used
#' @param palette color palette string (defaults to "YlGnBu")
#' @param legendtitle character string legend title
#' @param legYes plot legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotMonth(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotGlobalMan <- function(data,file,title,brks,palette="YlGnBu",legendtitle,legYes,eps){
  if (!length(palette)==(length(brks)-1)){colorRampPalette(RColorBrewer::brewer.pal(9,palette))(length(brks)-1)}
  ires=2
  legendticks=seq(from=0,to = 100,length.out = length(brks))
  data[data<brks[1]] <- brks[1]
  data[data>brks[length(brks)]] <- brks[length(brks)]
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=800*ires, height=400*ires, units="px",res=400,pointsize = 4)
  }
  ra <- raster::raster(ncols=360*ires, nrows=180*ires)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=brks,col=palette,main="",legend=FALSE,axes=FALSE,maxpixels=360*180*ires*ires)
  title(title,line=-1)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=range(brks),col = palette,useRaster=FALSE,breaks=legendticks,
                       lab.breaks=round(brks,2),legend.shrink = 0.8,legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  maps::map('world',add=TRUE,res=0, lwd=0.1,ylim=c(-60,90))
  dev.off()
}

#' Plot global country data
#'
#' Plot an array of country data, e.g. obtained from aggregateLPJmLdataCountry()
#'
#' @param data country array to be plotted c(ncountries)
#' @param cowList country-list giving the country code for each LPJmL cell dim=c(ncells)
#' @param file character string for location/file to save plot to
#' @param sty array with breaks to be used
#' @param title character string title for plot
#' @param palette color palette string (defaults to "YlGnBu")
#' @param legendtitle character string legend title
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#'
#' @return None
#'
#' @examples
#' plotCountryData(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotCountryData <- function(data,cowList,file,sty="lin",title="",legendtitle="",ncells=67420){
  ra=range(data,na.rm = T)
  if (sty=="lin"){
    brks=seq(from=ra[1],to = ra[2],length.out = 12)
    palette=RColorBrewer::brewer.pal(11,"Spectral")
  }else if (sty=="log"){
    if (min(data)<0){
      brks=c(-(2^seq(from=log(ra[2],base=2),to = 1,length.out = 6)),2^seq(from=1,to = log(ra[2],base=2),length.out = 6))
      palette=RColorBrewer::brewer.pal(11,"RdBu")
    }else{
      palette=RColorBrewer::brewer.pal(11,"Spectral")
      brks=c(0,2^seq(from=2,to = log(ra[2],base=2),length.out = 11))
    }
  }else{
    print("Style not known, use 'log' or 'lin'")
  }
  legendticks=seq(from=0,to = 100,length.out = length(brks))
  lpjdata=array(NA,dim=ncells)
  co=sort(unique(cowList))
  for (c in 1:length(co)){
    lpjdata[which(cowList==co[c])]=data[c]
  }
  png(file, width=1600, height=800, units="px",res=400,pointsize = 4)
  ra <- raster::raster(ncols=720, nrows=360)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  lpjdata
  extent <- raster::extent(c(-180, 180, -60, 90))
  par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  raster::plot(ra,ext=extent,breaks=brks,col=palette,main="",legend=FALSE,axes=FALSE,maxpixels=360*180*4)
  title(title,line=-1)
  fields::image.plot(legend.only=TRUE,zlim=range(brks),col = palette,useRaster=FALSE,breaks=legendticks,
                     lab.breaks=round(brks,2),legend.shrink = 0.8,legend.args=list(legendtitle,side=3, font=2, line=1))
  maps::map('world',add=TRUE,res=0, lwd=0.1,ylim=c(-60,90))
  dev.off()
}

#' Plot a zoomed in part from a LPJmL array
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted in range: c(-2^pow2max,-2^-pow2min,0,2^-pow2min,2^pow2max)
#'    colors for pos and neg values can be given, default is Blues for the positive
#'    and Reds for the negative numbers
#'    0-range (from 2^-pow2min to 2^pow2min) is white.
#'    The negatives can be omitted by setting onlyPos=T, in case there are only pos values.  
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param pow2min smallest positive number to be distinguished from 0 (2^-pow2min)
#' @param ext extent to be plotted c(xmin,xmax,ymin,ymax) 
#' @param colPos color palette for the positives
#' @param colNeg color palette for the negatives
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param onlyPos show only positive (boolean)
#' @param eps write eps file instead of PNG (boolean)
#' @param ires resolution factor (2 for 30min, 12 for 5min)
#' @param lon longitude array
#' @param lat latitude array
#' @param map boolean whether to add country borders to the plot (defaults to T)
#'
#' @return None
#'
#' @examples
#' plotRegionalW(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),pow2max=15,pow2min=0,ext=c(120,160,-10,10),
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE,ires=2,lon=lon,lat=lat,map=T)
#'
#' @export
plotRegionalW <- function(data,file,title,pow2max,pow2min,ext,colPos="Blues",colNeg="Reds",legendtitle,legYes,onlyPos=F,eps,ires=12,lon,lat,map=T){
  if (onlyPos){
    legendticks <- c(0,2^seq(pow2min,pow2max,1))
    brks <- c(seq(pow2min,pow2max,length.out = length(legendticks)))
    palette <- c("white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)-2))  
  }else{
    legendticks <- c(-(2^seq(pow2max,pow2min,-1)),2^seq(pow2min,pow2max,1))
    brks <- seq(-pow2max,pow2max,length.out = length(legendticks))
    palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(length(legendticks)/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)/2-1))
  }
  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=800*ires, height=400*ires, units="px",res=400,pointsize = 4)
  }
  #print(paste(ires,length(lon),length(lat)))
  ra <- raster::raster(ncols=360*ires, nrows=180*ires)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(ext)
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=legendticks,col=palette,main="",legend=FALSE,axes=FALSE,maxpixels=360*180*ires*ires)
  title(title,line=-1)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=c(-pow2max,pow2max),col = palette,useRaster=FALSE,breaks=brks,lab.breaks=round(legendticks,2),legend.shrink = 0.8,
                       legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  if(map){maps::map('world',add=TRUE,res=0, lwd=0.1,ylim=c(-60,90))}
  dev.off()
}

#' Plot basin to screen
#'
#' Plot all cells of a basin for given cell index to R internal screen
#' target cell is marked red, basin cells blue
#'
#' @param cell index of the cell, whose basin should be plotted
#' @param endcellList lpjml array giving the index of the final drainage cell for each cell 
#' @param zoom zoom in? (boolean) otherwise global plot
#' @param off offset amount in degrees to each side of the cell, only applied of zoom==T (defaults to 20)
#' @param ncells number of lpj cells (67420 for 30min res, 2298847 for 5min res)
#' 
#' @return None
#'
#' @examples
#' plotBasin2screen(cell=20000,endcellList=endcell,zoom=F,off=20)
#'
#' @export
plotBasin2screen <- function(cell,endcellList,zoom=F,off=20,ncells=67420){#ind is vector
  data=array(0,dim=c(ncells))
  e=endcellList[cell]
  data[which(endcellList==e)]=1
  data[cell]=2
  palette <- c("white","blue","red")
  brks <- c(-0.5,0.5,1.5,2.5)
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  ext=c(-180, 180, -60, 90)
  if (zoom){ext=c(lon[cell]-off,lon[cell]+off,lat[cell]-off,lat[cell]+off)}
  extent <- raster::extent(ext)
  par(bty="n",mar=c(0,0,0,0),oma=c(0,0,0,0))
  raster::plot(ra,ext=extent,breaks=brks,col=palette,main="",legend=FALSE,axes=FALSE)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
}

#' Plot global LPJmL grid with flexibility to zoom into a region,
#'
#' Creates a PNG/eps with a plot 
#'
#' @param data array with month index to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param legendtitle character string legend title
#' @param legYes plot legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotMonth(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotGlobalWflex <- function(data,file,title,man=F,mbrk=-1,mpalette=-1,pow2max,pow2min,colPos="Blues",colNeg="Reds",legendtitle,legYes,onlyPos=F,eps,ires=12,lon,lat,map=T,ext=c(-180, 180, -60, 90),logscale=T){
  
  if (logscale){
    if (onlyPos){
      legendticks <- c(0,2^seq(pow2min,pow2max,1))
      brks <- c(seq(pow2min,pow2max,length.out = length(legendticks)))
      palette <- c("white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)-2))  
    }else{
      legendticks <- c(-(2^seq(pow2max,pow2min,-1)),2^seq(pow2min,pow2max,1))
      brks <- seq(-pow2max,pow2max,length.out = length(legendticks))
      palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(length(legendticks)/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)/2-1))
    }
  }else{
    if (!man){
    lout=1+2*7
    if (onlyPos){
      legendticks <- round(seq(0,(2^pow2max),length.out = lout),0)
      brks <- legendticks
      palette <- c("white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)-2))
    }else{
      legendticks <- round(seq(-(2^pow2max),(2^pow2max),length.out = lout),0)
      brks <- legendticks
      palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(length(legendticks)/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)/2-1))
    }
    }else{
      brks=mbrk
      legendticks=mbrk
      palette=mpalette
    }
  }

  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  if (max(ext[1:2])>180){
    lon[lon<0]=lon[lon<0]+360
  }
  #print(paste0("range(lon)",range(lon)))
  xmagn=(ext[2]-ext[1])/360
  ymagn=(ext[4]-ext[3])/180
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=800*ires*xmagn, height=360*ires*ymagn, units="px",res=400,pointsize = 4)
  }
  ra <- raster::raster(ncols=360*ires, nrows=180*ires)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(ext)
  if (legYes){
    par(bty="n",oma=c(0,0,0,6),mar=c(0,0,0,6),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=legendticks,col=palette,main="",legend=FALSE,axes=FALSE,maxpixels=360*180*ires*ires)
  title(title,line=-1,cex.main=4*xmagn*ires/12)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=range(data),col = palette,useRaster=FALSE,breaks=brks,lab.breaks=round(legendticks,2),legend.width = 6*xmagn,
                       legend.args=list(legendtitle,side=3, font=2, line=0),axis.args=list(cex.axis=4*xmagn*ires/12))
  }
  if(map){maps::map('world',add=TRUE,res=0, lwd=0.1,ylim=c(-60,90))}
  dev.off()
}


#' Plot global month indices on LPJmL grid, for example for months with highest precipitation
#'
#' Creates a PNG/eps with a plot of a month index from 1:12
#'
#' @param data array with month index to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param legendtitle character string legend title
#' @param legYes plot legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotMonth(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotMonth <- function(data,file,title,legendtitle,legYes,eps){
  #legendticks <- c("extreme high","high","medium","low","no","low","medium","high","extreme high")
  brks <- seq(-0.5,12.5,1)  
  
  data[data<0] <- 0
  data[data>12] <- 0 
  
  palette <- c("gray",RColorBrewer::brewer.pal(12,"Paired")[c(1,2,11,3,4,7,8,5,6,12,9,10)])
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=brks,col=palette,main="",legend=FALSE,axes=FALSE)
  title(title,line=-1)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
  if (legYes){
    legend("right",legend=c("NA","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"),fill = palette,title=legendtitle)
  }
  dev.off()
}


#' Plot global LPJmL array
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted in range: c(-2^pow2max,-2^-pow2min,0,2^-pow2min,2^pow2max)
#'    colors for pos and neg values can be given, default is Blues for the positive
#'    and Reds for the negative numbers
#'    0-range (from 2^-pow2min to 2^pow2min) is white.
#'    The negatives can be omitted by setting onlyPos=T, in case there are only pos values.  
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param pow2min smallest positive number to be distinguished from 0 (2^-pow2min)
#' @param colPos color palette for the positives
#' @param colNeg color palette for the negatives
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param onlyPos show only positive (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotGlobalW(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),pow2max=15,pow2min=0,
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotGlobalW <- function(data,file,title,pow2max,pow2min,colPos="Blues",colNeg="Reds",legendtitle,legYes,onlyPos=F,eps){
  if (onlyPos){
    legendticks <- c(0,2^seq(pow2min,pow2max,1))
    brks <- c(seq(pow2min,pow2max,length.out = length(legendticks)))
    palette <- c("white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)-2))  
  }else{
    legendticks <- c(-(2^seq(pow2max,pow2min,-1)),2^seq(pow2min,pow2max,1))
    brks <- seq(-pow2max,pow2max,length.out = length(legendticks))
    palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(length(legendticks)/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)/2-1))
  }
  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=legendticks,col=palette,main="",legend=FALSE,axes=FALSE)
  title(title,line=-1)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=c(-pow2max,pow2max),col = palette,useRaster=FALSE,breaks=brks,lab.breaks=round(legendticks,2),legend.shrink = 0.8,
                       legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
  dev.off()
}

#' Plot global LPJmL array
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted linearly in range: c(-max,min,0,min,max)
#'    colors for pos and neg values can be given, default is Blues for the positive
#'    and Reds for the negative numbers
#'    0-range (from -min to min) is white.
#'    The negatives can be omitted by setting onlyPos=T, in case there are only pos values.  
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param max upper (positive) end of data range to plot
#' @param min smallest positive number to be distinguished from 0
#' @param colPos color palette for the positives
#' @param colNeg color palette for the negatives
#' @param colrev reverse positive color palette if onlyPos (boolean)
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param onlyPos show only positive (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotGlobalWlin(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep="")max=15,min=0,
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotGlobalWlin <- function(data,file,title,max,min,colPos="Blues",colNeg="Reds",colrev=F,legendtitle,legYes,onlyPos=F,eps){
  if (onlyPos){
    lengthbrks <- 16
    if (max-min > 10){
      brks <- round(seq(min,max,length.out = lengthbrks),0)
    }else{
      brks <- round(seq(min,max,length.out = lengthbrks),1)
    }
    if (colrev) palette <- c("white",rev(colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(lengthbrks-2)))  
    else palette <- c("white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(lengthbrks-2)) 
  }else{
    lengthbrks <- 24
    if (max-min > 10){
      brks <- round(seq(-max,max,length.out = lengthbrks),0)
    }else{
      brks <- round(seq(-max,max,length.out = lengthbrks),1)
    }
    palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(lengthbrks/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(lengthbrks/2-1))
  }
  data[data<brks[1]] <- brks[1]
  data[data>brks[length(brks)]] <- brks[length(brks)]
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=brks,col=palette,main="",legend=FALSE,axes=FALSE)
  title(title,line=-1)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=c(-max,max),col = palette,useRaster=FALSE,breaks=brks,lab.breaks=brks,legend.shrink = 0.8,
                       legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
  dev.off()
}

#' Plot global LPJmL array with weighted sums of the pos and neg values
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted in range: c(-2^pow2max,-2^-pow2min,0,2^-pow2min,2^pow2max)
#'    colors for pos and neg values can be given, default is Blues for the positive
#'    and Reds for the negative numbers
#'    0-range (from 2^-pow2min to 2^pow2min) is white.
#'    Also globally weighted sums for all pos and neg values are plotted. 
#'    
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param pow2min smallest positive number to be distinguished from 0 (2^-pow2min)
#' @param colPos color palette for the positives
#' @param colNeg color palette for the negatives
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' plotGlobalWsum(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),pow2max=15,pow2min=0,
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#'
#' @export
plotGlobalWsum <- function(data,popData=0,file,title,pow2max,pow2min,colPos="Blues",colNeg="Reds",posLab="Pos",negLab="Neg",legendtitle,legYes,eps,pie=T){
  legendticks <- c(-(2^seq(pow2max,pow2min,-1)),2^seq(pow2min,pow2max,1))
  brks <- seq(-pow2max,pow2max,length.out = length(legendticks))
  data[which(!is.finite(data))] <- 0
  if (!length(popData)==1){
    pdata=data*popData
    ptot=sum(pdata[pdata>0])-sum(pdata[pdata<0])
    psump=sum(pdata[pdata>0])/ptot*100
    psumn=-sum(pdata[pdata<0])/ptot*100
    pp=round(cbind(psump,psumn),0)
  }
  gdata=data*cellarea
  gtot=sum(gdata[gdata>0])-sum(gdata[gdata<0])
  gsump=sum(gdata[gdata>0])/gtot*100
  gsumn=-sum(gdata[gdata<0])/gtot*100
  gp=round(cbind(gsump,gsumn),0)
  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,colNeg))(length(legendticks)/2-1)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,colPos))(length(legendticks)/2-1))
  if (eps){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  modLegendTicks=seq(0,length(legendticks)-1,1)
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  raster::plot(ra,ext=extent,breaks=legendticks,col=palette,main="",legend=FALSE,axes=FALSE)
  title(title,line=-1)
  if (legYes){
    fields::image.plot(legend.only=TRUE,zlim=c(-pow2max,pow2max),col = palette,useRaster=FALSE,breaks=brks,lab.breaks=round(legendticks,2),legend.shrink = 0.8,
                       legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
  dev.off()
  file=strsplit(file,".",fixed=TRUE)[[1]]
  if (eps){
    file=paste(paste(c(file[1:(length(file)-1)]),collapse="."),"_legend.eps",sep="")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=5, height=5,paper="special")
  }else{
    file=paste(paste(c(file[1:(length(file)-1)]),collapse="."),"_legend.png",sep="")
    png(file, width=2.5, height=2.5, units="in",bg = "transparent",res=300, pointsize=6,type="cairo")
  }
  par(oma=c(0,0,0,0),mar=c(4,4,4,4),xpd=T)
  if (pie){
    #par(fig=c(0,0.2,0,0.2),oma=c(0,0,0,0),mar=c(0,0,0,0))
    pie(x = gp,labels = paste(gp,"%",sep=""),col = palette[c(length(palette)-3,4)],cex=2)
  }else{
    plot(0,0,xlim=c(-205,-120),ylim=c(-60,25),xaxt="n",type="n",yaxt="n")
    legend(-200,20,c("Area weighted:",paste(c(paste(posLab,": ",sep=""),paste(negLab,": ",sep="")),gp,"%",sep="")),text.col=c("black",palette[c(length(palette),1)]),pt.cex=3,lty=0,lwd=1,cex = 1.5,bty = "n")
    if (!length(popData)==1){
      legend(-200,-10,c("Population weighted:",paste(c(paste(posLab,": ",sep=""),paste(negLab,": ",sep="")),pp,"%",sep="")),text.col=c("black",palette[c(length(palette),1)]),pt.cex=3,lty=0,lwd=1,cex = 1.5,bty = "n")
    }
  }
  dev.off()
  
}



#' Plot global LPJmL array inside RStudio
#'
#' Plot of a global LPJmL array inside RStudio
#'    Data is plotted in range: c(-2^pow2max,-2^-pow2min,0,2^-pow2min,2^pow2max)
#'    where the positive values are colored green to blue,
#'    0-range is white,
#'    and the negative ones red to yellow
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param title character string title for plot
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param pow2min smallest positive number to be distinguished from 0 (2^-pow2min)
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#'
#' @return None
#
#' @examples
#' plotGlobalWtoscreen(data=irrigation2006,title = paste("irrigation amount 2006 in mm/yr",sep=""),
#'                     pow2max=15,pow2min=0,"legendtitle",legYes=TRUE)
#'
#' @export
plotGlobalWtoscreen <- function(data,title,pow2max,pow2min,legendtitle,legYes){
  legendticks <- c(-(2^seq(pow2max,-pow2min,-1)),2^seq(-pow2min,pow2max,1))
  brks <- seq(-pow2max,pow2max,length.out = length(legendticks))
  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  palette <- c(rev(colorRampPalette(RColorBrewer::brewer.pal(9,"YlOrRd"))(pow2max+pow2min)),"white",colorRampPalette(RColorBrewer::brewer.pal(9,"GnBu"))(pow2max+pow2min))
  ra <- raster::raster(ncols=720, nrows=360)
  range <- range(data)
  ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- raster::extent(c(-180, 180, -60, 90))
  modLegendTicks=seq(0,length(legendticks)-1,1)
  par(mar=c(0,0,0,3),oma=c(0,0,0,0),bty="n")
  raster::plot(ra,ext=extent,breaks=legendticks,col=palette,main=title,legend=FALSE,axes=FALSE)
  if (legYes){
    legendtitle=""
    fields::image.plot(legend.only=TRUE,zlim=c(-pow2max,pow2max),col = palette, breaks=brks,lab.breaks=legendticks,legend.shrink = 0.7,
                       legend.args=list(legendtitle,side=4, font=2, line=2.5))
  }
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))
}

#' Plot global LPJmL array with only positive values
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted in range: c(0,2^pow2max)
#'    positive values are colored accoding to chosen palette,
#'    0-range is white,
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param col color palette name from brewer.pal (character string)
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' \dontrun{
#' plotGlobal_pos(data=irrigation2006,file=paste("~/","mwateramount_2005_06.png",sep=""),
#'             title = paste("irrigation amount 2006 in mm/yr",sep=""),pow2max=15,col="GnBu",
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#' }
#' @export
plotGlobal_pos <- function(data,file,title,pow2max,col,legendtitle,legYes,eps){
  legendticks <- c(0,2^seq(0,(pow2max+1),1))
  brks <- seq(0,(pow2max+1),length.out = length(legendticks))
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  palette <- c("white",colorRampPalette(brewer.pal(9,col))(length(legendticks)-2))
  if (eps){
    file=strsplit(file,".",fixed=T)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster(ncols=720, nrows=360)
  range <- range(data)
  ra[cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  plot(ra,ext=extent,breaks=legendticks,col=palette,main=title,legend=F,axes=F)
  if (legYes){
    image.plot(legend.only=T,zlim=c(0,pow2max+1),col = palette,useRaster=F,breaks=brks,legend.shrink = 0.8,
               #axis.args=list(at=brks,labels=legendticks),
               legend.args=list(legendtitle,side=3, font=2, line=1),axis.args=list(at=brks[1:(length(brks)-1)],labels=legendticks[1:(length(legendticks)-1)]))
  }
  map('world',add=T,res=0.4, lwd=0.25)
  dev.off()
}

#' Plot global LPJmL array with positive and negative values
#'
#' Creates a PNG/eps with a plot of a global LPJmL array
#'    Data is plotted in range: c(-2^negpow2max,2^pow2max)
#'    positive and negative values are colored accoding to chosen palettes,
#'    0-range is white,
#'
#' @param data array with data to plot in LPJmL specific array c(67420)
#' @param file character string for location/file to save plot to
#' @param title character string title for plot
#' @param negpow2max lower (negative) end of data range to plot (-2^negpow2max)
#' @param pow2max upper (positive) end of data range to plot (2^pow2max)
#' @param poscol color palette name from brewer.pal (character string) for positive values
#' @param negcol color palette name from brewer.pal (character string) for negative values
#' @param legendtitle character string legend title
#' @param legYes show legend (boolean)
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#'
#' @examples
#' \dontrun{
#' plotGlobal_pos_neg(data=EFR_deficits2006,file=paste("~/","EFRdeficits_06.png",sep=""),
#'             title = "",negpow2max=10, pow2max=15,negcol="GnBu",poscol="Reds"
#'             legendtitle="legendtitle",legYes=TRUE,eps=FALSE)
#' }
#' @export
plotGlobal_pos_neg <- function(data,file,title,pow2max,negpow2max,negcol, poscol,legendtitle,legYes,eps){
  legendticks <- c(-(2^seq(negpow2max+1,0,-1)),2^seq(0,pow2max+1,1))
  brks <- seq(-(negpow2max+1),(pow2max+1),length.out = length(legendticks))
  data[data<legendticks[1]] <- legendticks[1]
  data[data>legendticks[length(legendticks)]] <- legendticks[length(legendticks)]
  if (pow2max<negpow2max){
    palette  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[1:9]))(length(seq(negpow2max+1,0,-1))-1),"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[1:9])(length(seq((negpow2max+1),0,-1))-1)[1:(pow2max+1)])
  } else if (pow2max>negpow2max){
    palette  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[1:9]))(length(seq(0,pow2max+1,1))-1)[(length(seq(0,pow2max+1,1))-(negpow2max+1)):(length(seq(0,pow2max+1,1))-1)],"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[1:9])(length(seq(0,pow2max+1,1))-1))
  } else {
    palette  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[1:9]))(length(seq(negpow2max+1,0,-1))-1),"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[1:9])(length(seq(0,pow2max+1,1))-1))
  }
  if (eps){
    file=strsplit(file,".",fixed=T)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=22, height=8.5,paper="special")
  }else{
    png(file, width=7.25, height=3.5, units="in", res=300, pointsize=6,type="cairo")
  }
  ra <- raster(ncols=720, nrows=360)
  range <- range(data)
  ra[cellFromXY(ra,cbind(lon,lat))] <-  data
  extent <- extent(c(-180, 180, -60, 90))
  if (legYes){
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  }else{
    par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,0))
  }
  plot(ra,ext=extent,breaks=legendticks,col=palette,main="",legend=F,axes=F)
  title(title, line = -1)
  if (legYes){
    image.plot(legend.only=T,zlim=c(-(negpow2max+1),pow2max),col = palette,useRaster=F,breaks=brks,legend.shrink = 0.8,
               axis.args=list(at=brks[2:(length(brks)-1)],labels=legendticks[2:(length(legendticks)-1)]),
               legend.args=list(legendtitle,side=3, font=2, line=1))
  }
  map('world',add=T,res=0.4, lwd=0.25)
  dev.off()
}

#' Plot global LPJmL CFT array inside RStudio
#'
#' Plot of one band of a global LPJmL cft array inside RStudio
#'            with classification into 10% classes.
#'
#' @param lushares array with cft band data to plot in LPJmL specific array c(67420)
#' @param title character string title for plot
#' @param legendtitle character string legend title
#'
#' @return None
#
#' @examples
#' \dontrun{
#' plotLUsharesToScreen(lushares=cftfracs2005[,3],title = "cft fracs for maize",legendtitle="")
#' }
#'
#' @export

plotLUsharesToScreen <- function(lushares,title,legendtitle){
  par(mar=c(4, 0, 4, 15) + 0.1,oma=c(0,0,0,2))
  par(cex=1.2,cex.main=1.2)
  cols  <- c(RColorBrewer::brewer.pal(10,"RdYlBu"),"white")
  range <- c(0,1)
  brk   <- c(0,0.001,seq(0,1,0.1)[2:length(seq(0,1,0.1))])
  par(cex=1.2,cex.main=1.2)
  lu.ras <- raster::raster(ncols=720, nrows=360)
  lu.ras[raster::cellFromXY(lu.ras,cbind(lon,lat))] <-  1-lushares
  raster::plot(lu.ras,ylim=c(-60,90),xlim=c(-180,180),zlim=range,breaks=brk,col=(cols),legend=F,xaxt="n",yaxt="n",main=title,axes=F,box=F)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))  #Legend
  par(xpd=T)
  legend(190,70,title=legendtitle,cex=1.6,
         rev(c("0","0-10%","11-20%","21-30%","31-40%","41-50%","51-60%","61-70%","71-80%","81-90%","91-100%")),
         fill=(cols), horiz=F,border=NULL,bty="o",box.col="white",bg="white",ncol=1)
  text(190,70,pos=4,"landuse intensity",cex=1.6)
  par(xpd=F)
}

#' Plot global LPJmL CFT array
#'
#' Plot of one band of a global LPJmL cft array
#'             classification into 10% classes.
#'
#' @param file character string for location/file to save plot to
#' @param lushares array with cft band data to plot in LPJmL specific array c(67420)
#' @param title character string title for plot
#' @param legendtitle character string legend title
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#
#' @examples
#' \dontrun{
#' plotLUshares(file="~/cftfracs2005_maize.png",lushares=cftfracs2005[,3],
#'              title = "cft fracs for maize",legendtitle="",eps=FALSE)
#' }
#'
#' @export
plotLUshares <- function(file,lushares,title,legendtitle,eps){
  if (eps){
    file=strsplit(file,".",fixed=T)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18) 
    postscript(file,horizontal = FALSE, onefile = FALSE, width=20, height=10,paper="special")
  }else{
    png(file, width=7.2, height=3.6, units="in", res=300, pointsize=6,type="cairo")
  }
  par(mar=c(4, 0, 4, 15) + 0.1,oma=c(0,0,0,2))
  par(cex=1.2,cex.main=1.2)
  cols  <- c(RColorBrewer::brewer.pal(10,"RdYlBu"),"white")
  range <- c(0,1)
  brk   <- c(0,0.001,seq(0,1,0.1)[2:length(seq(0,1,0.1))])
  par(cex=1.2,cex.main=1.2)
  lu.ras <- raster::raster(ncols=720, nrows=360)
  lu.ras[raster::cellFromXY(lu.ras,cbind(lon,lat))] <-  1-lushares
  raster::plot(lu.ras,ylim=c(-60,90),xlim=c(-180,180),zlim=range,breaks=brk,col=(cols),legend=F,xaxt="n",yaxt="n",main=title,axes=F,box=F)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))  #Legend
  par(xpd=T)
  legend(190,70,title=legendtitle,cex=1.6,
         rev(c("0","0-10%","11-20%","21-30%","31-40%","41-50%","51-60%","61-70%","71-80%","81-90%","91-100%")),
         fill=(cols), horiz=F,border=NULL,bty="o",box.col="white",bg="white",ncol=1)
  text(190,70,pos=4,"landuse intensity",cex=1.6)
  par(xpd=F)
  dev.off()
}

#' Plot global LPJmL CFT array
#'
#' Plot of one band of a global LPJmL cft array
#'             classification into 10% classes, except for first class: 0-1%, 1-10%, 
#'             colors according to chosen palette
#'
#' @param file character string for location/file to save plot to
#' @param lushares array with cft band data to plot in LPJmL specific array c(67420)
#' @param title character string title for plot
#' @param col color palette name from brewer.pal (character string)
#' @param legendtitle character string legend title
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#
#' @examples
#' \dontrun{
#' plotLUshares2(file="~/cftfracs2005_maize.png",lushares=cftfracs2005[,3],
#'              title = "cft fracs for maize",col="Reds",legendtitle="",eps=FALSE)
#' }
#'
#' @export

plotLUshares2<- function(file,lushares,title, col, legendtitle, eps){
  if (eps){
    file=strsplit(file,".",fixed=T)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18) 
    postscript(file,horizontal = FALSE, onefile = FALSE, width=20, height=10,paper="special")
  }else{
    png(file, width=7.2, height=3.6, units="in", res=300, pointsize=6,type="cairo")
  }
  par(cex=1.2,cex.main=1.2)
  cols  <- c("white",RColorBrewer::brewer.pal(9,col)[2],colorRampPalette(RColorBrewer::brewer.pal(9,col)[3:9])(10))
  range <- c(0,1)
  brk   <- c(0,0.0001,0.01,seq(0,1,0.1)[2:length(seq(0,1,0.1))])
  lu.ras <- raster::raster(ncols=720, nrows=360)
  lu.ras[raster::cellFromXY(lu.ras,cbind(lon,lat))] <-  lushares
  extent <- raster::extent(c(-180, 180, -60, 90))
  legend.breaks<- c(0,0.05,seq(0.05,1,0.095)[2:length(seq(0.05,1,0.095))]) # damit auch 0 bis 1 in der Legende sichtbar ist
  legend.cols <-c(RColorBrewer::brewer.pal(9,col)[2],colorRampPalette(RColorBrewer::brewer.pal(9,col)[3:9])(10))
  par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  raster::plot(lu.ras,ext=extent,breaks=brk,col=(cols),legend=F,main=title,axes=F,box=F)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))  #Legend
  fields::image.plot(legend.only=TRUE,zlim=range,col = legend.cols,useRaster=FALSE,breaks=legend.breaks,lab.breaks=c("0","1 %","10 %","20 %","30 %","40 %","50 %","60 %","70 %","80 %","90 %","100 %"),legend.shrink = 0.8,
                     legend.args=list(legendtitle,side=3, font=2, line=1))
  dev.off()
}

#' Plot bioenergy harvest over time
#'
#' Plot bioenergy harvest over time
#'
#' @param file character string for location/file to save plot to
#' @param beHarvest array yearly beharvest data -- array c(years,type,clim,rf:irr)
#' @param title character string title for plot
#' @param eps write eps file instead of PNG (boolean)
#'
#' @return None
#
#' @examples
#' \dontrun{
#' plotBEharvest(file="beHarvest.png",beHarvest=beHarvestYearly,
#'              title = "",eps=FALSE)
#' }
#'
#' @export
plotBEharvest <- function(file,beHarv,beHarv_cal,title,expFormat="png"){
  if (expFormat=="eps"){
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"eps"),collapse=".")
    ps.options(family = c("Helvetica"), pointsize = 18)
    postscript(file,horizontal = FALSE, onefile = FALSE, width=18, height=18,paper="special")
  }else if (expFormat=="pdf"){  
    file=strsplit(file,".",fixed=TRUE)[[1]]
    file=paste(c(file[1:(length(file)-1)],"pdf"),collapse=".")
    pdf(file,width=14.4,height=7.2,family = c("Helvetica"),pointsize = 12,paper='special',version = "1.5")
  }else{
    png(file, width=7.2, height=3.6, units="in", res=500, pointsize=6,type="cairo")
  }
  par(fig=c(0,0.9,0,1),oma=par("oma")+c(0,0.1,0,0))
  plot(0,type="n", xlim=c(2006,2099), ylim=c(0,11.5),xlab="Year", ylab="harvest [GtC]",main=title,cex.axis=1.5,cex.lab=1.5,xaxs = "i", yaxs = "i")
  grid(ny=NULL,nx=NULL)
  cols=rep("white",12)
  ind=c(5,11,1,12,6,8,18,10,16,13,17,14,15)
  cols[ind]=alpha(c("gray30","orange","orangered","red3","red4","lawngreen","yellowgreen","limegreen","green4","turquoise1","steelblue1","royalblue","royalblue4"),0.7)#RColorBrewer::brewer.pal(10,"Paired")[c(7,8,5,6,3,4,9,1,2,10)])
  ltys=c("solid", "dashed", "dotted", "longdash")#, "dotdash")
  clims=c("HadGEM","MIROC5","GFDL","IPSL")
  scens=c("baseline 0","noefr 15","noefr 30","noefr 45","noefr 60","efr 30","efr 45","efr 60","efr 90","efrwm 30","efrwm 45","efrwm 60","efrwm 90")
  #plot sums
  ytop=11.2
  xpos=seq(2011,2046,length.out = 6)
  rect(xleft = 2006,ybottom = 3.9,xright = xpos[length(xpos)]+2,ytop = ytop+0.3,col = "white")
  text(x=xpos,y=ytop,labels=c("Sum [GtC]",c(clims,"mean")),cex=0.9)
  text(x=xpos,y=ytop-1*0.5,labels=c("ISIMIP2b demand",round(c(colSums(apply(beHarv_cal[,ind[1],1:4,],c(1,2),sum)),mean(colSums(apply(beHarv_cal[,ind[1],1:4,],c(1,2),sum)))),0)),cex=0.9)
  for (i in 1:(length(beHarv[1,,1,1])-5)){
    text(x=xpos,y=ytop-(i+1)*0.5,labels=c(scens[i],round(c(colSums(apply(beHarv[,ind[i],1:4,],c(1,2),sum)),mean(colSums(apply(beHarv[,ind[i],1:4,],c(1,2),sum)))),0)),cex=0.9)
  }
  #plot lines
  for (t in ind[1:(length(beHarv[1,,1,1])-5)]){
    for (c in 1:4){
      lines(x=2006:2099,y=rowSums(beHarv[,t,c,]),col=cols[t],lty=ltys[c])
    }
  }
  colb=alpha("black",0.7)
  for (c in 1:4){
    lines(x=2006:2099,y=rowSums(beHarv_cal[,5,c,]),col=colb,lty=ltys[c])
  }
  legend(2085,5.4,title="scenario",legend = c("ISIMIP2b demand",scens[1:(length(beHarv[1,,1,1])-5)]),col=c(colb,cols[ind]), lty="solid",cex=0.8)
  legend(2067,4,title="climate",legend = clims,col="black", lty=ltys,cex=0.8)
  par(fig=c(0.9,1,0.0,1), mar=c(5.1, 0, 4.1, 0),new=TRUE,xpd=T)
  plot(0,type="n", xlim=c(0,1), ylim=c(0,100),xlab="", ylab="",main="",cex.axis=1.5,cex.lab=1.5,axes=F)
  # plot new prod. increase axis and labels
  ys=c(mean(apply(beHarv_cal[,5,1:4,],c(2),sum)),rowMeans(apply(beHarv[,ind,1:4,],c(2,3),sum)))
  yp=round((ys-ys[2])/(ys[1]-ys[2])*100)
  #lines(x=rep(0.2,2),y=yp[1:2],col="black",lwd=0.7)
  text(x=0.65,y=yp,labels=paste(yp,"%"),adj=1,cex=1)
  text(x=0.85,y=(yp[1]+yp[2])/2,labels="total productivity increase",srt=90,cex=1)
  #plot means
  b=yp[1]
  yp=yp[2:length(yp)]
  for (i in 1:(length(beHarv[1,,1,1])-5)){
    xs=c(0.05,0.25)
    #if (i==11 || i==9){xs=c(0,0.15)}
    #else if(i==3 || i==4){xs=c(0.15,0.3)}
    lines(x=xs,y=rep(yp[i],2),col=cols[ind[i]],lwd=1.5,xaxt="n")
  }
  lines(x=c(0.05,0.25),y=rep(b,2),col=colb,lwd=1.5,xaxt="n")
  #lines(x=c(0,0.2),y=rep(mean(rowSums(beHarv_cal[94,5,,])),2),col=colb,lwd=1.5)
  dev.off()
}

#' Plot global relative differences
#'
#' Plot of relative differences derived from two LPJmL arrays
#'             classification into 10% classes
#'
#' @param file character string for location/file to save plot to
#' @param diff_data array with relative differences in LPJmL specific array c(67420)
#' @param min lower end of data range (between -1.5 and 0, with one digit allowed to the left of the decimal point); one additional break is added to display values lower than min
#' @param max upper end of data range (between 0 and 1.5, with one digit allowed to the left of the decimal point); one additional break is added to display values higher than max
#' @param title character string title for plot
#' @param poscol color palette name from brewer.pal (character string) for poitive values
#' @param negcol color palette name from brewer.pal (character string) for negative values
#' @param legendtitle character string legend title
#'
#' @return None
#
#' @examples
#' \dontrun{
#' plot_relDiff(file="~/difference_in_soil_carbon_2005_2006.png",diff_data=diff_soilc_2005_2006, min=-0.5, max=0.7, negcol="Reds", poscol="Blues",
#'              title = "relative difference in soil carbon between 2005 and 2006",legendtitle="diff. in %",eps=FALSE)
#' }
#'
#' @export
plot_relDiff <- function(file,diff_data, min, max, negcol, poscol, title,legendtitle){
  png(file, width=7.2, height=3.6, units="in", res=300, pointsize=6,type="cairo")
  par(cex=1.2,cex.main=1.2)
  if (max<abs(min)&&max!=0){
    cols  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(min-0.1,0,0.1))-1)[1:((max+0.1)*10)])
    legend.cols<-c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(min-0.1,0,0.1))-1)[1:((max+0.1)*10)])
  } else if (max>abs(min)&&min!=0){
    cols  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(0,max+0.1,0.1))-1)[((length(seq(0,max+0.1,0.1))-1)-(abs(min-0.1)*10)+1):(length(seq(0,max+0.1,0.1))-1)],"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(0,max+0.1,0.1))-1))
    legend.cols<-c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(0,max+0.1,0.1))-1)[((length(seq(0,max+0.1,0.1))-1)-(abs(min-0.1)*10)+1):(length(seq(0,max+0.1,0.1))-1)],colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(0,max+0.1,0.1))-1))
  } else if (max==0){
    cols  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),"white",RColorBrewer::brewer.pal(3,poscol)[3])
    legend.cols<-c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),RColorBrewer::brewer.pal(3,poscol)[3])
  } else if (min==0){
    cols  <- c(RColorBrewer::brewer.pal(3,negcol)[3],"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(0,max+0.1,0.1))-1))
    legend.cols<-c(RColorBrewer::brewer.pal(3,negcol)[3],colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(0,max+0.1,0.1))-1))
  } else {
    cols  <- c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),"white",colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(0,max+0.1,0.1))-1))
    legend.cols<-c(colorRampPalette(rev(RColorBrewer::brewer.pal(9,negcol)[3:9]))(length(seq(min-0.1,0,0.1))-1),colorRampPalette(RColorBrewer::brewer.pal(9,poscol)[3:9])(length(seq(min-0.1,0,0.1))-1))
  }
  range <- c(min-0.1,max+0.1)
  brk   <- c(seq(min-0.1,0,0.1)[1:(length(seq(min-0.1,0,0.1))-1)],-0.0001,0.0001,seq(0,max+0.1,0.1)[2:length(seq(0,max+0.1,0.1))])
  diff_data[diff_data<brk[1]] <- brk[1] #smaller values than min also displayed 
  diff_data[diff_data>brk[length(brk)]] <- brk[length(brk)] #higher values than max also displayed 
  lu.ras <- raster::raster(ncols=720, nrows=360)
  lu.ras[raster::cellFromXY(lu.ras,cbind(lon,lat))] <-  diff_data
  extent <- raster::extent(c(-180, 180, -60, 90))
  if(max==0){
    legendlabel<-c(as.character(c(paste(round(brk*100,0),"%",sep=" ")))[2:(length(seq(min-0.1,0,0.1))-1)],0)
  }
  else if (min==0){
    legendlabel<-c(0, as.character(c(paste(round(brk*100),"%",sep=" ")))[(length(brk)-length(seq(0,max+0.1,0.1))+2):(length(brk)-1)])
  } else {
    legendlabel<-c(as.character(c(paste(round(brk*100,0),"%",sep=" ")))[2:(length(seq(min-0.1,0,0.1))-1)],0, as.character(c(paste(round(brk*100),"%",sep=" ")))[(length(brk)-length(seq(0,max+0.1,0.1))+2):(length(brk)-1)])
  }
  legend.breaks<- c(seq(min-0.1,-0.1,0.1),0,seq(0.1,max+0.1,0.1))
  par(bty="n",oma=c(0,0,0,0),mar=c(0,0,0,3),xpd=T)
  raster::plot(lu.ras,ext=extent,zlim=range,breaks=brk,col=(cols),legend=F,xaxt="n",yaxt="n",main=title,axes=F,box=F)
  maps::map('world',add=TRUE,res=0.4, lwd=0.25,ylim=c(-60,90))  #Legend
  fields::image.plot(legend.only=TRUE,zlim=range,col = legend.cols,useRaster=FALSE,breaks=legend.breaks,legend.shrink = 0.8,
                     legend.args=list(legendtitle,side=3, font=2, line=1),axis.args=list(at=legend.breaks[2:(length(legend.breaks)-1)],labels=legendlabel))
  dev.off()
}

#' Copy of the pie function with labels further away from pie
#'
#' Copy of the pie function with labels further away from pie
#'
#' @export
pie2 <- function (x, labels = names(x), edges = 200, radius = 0.8, clockwise = FALSE, 
          init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45, 
          col = NULL, border = NULL, lty = NULL, main = NULL, ...) 
{
  if (!is.numeric(x) || any(is.na(x) | x < 0)) 
    stop("'x' values must be positive.")
  if (is.null(labels)) 
    labels <- as.character(seq_along(x))
  else labels <- as.graphicsAnnot(labels)
  x <- c(0, cumsum(x)/sum(x))
  dx <- diff(x)
  nx <- length(dx)
  plot.new()
  pin <- par("pin")
  xlim <- ylim <- c(-1, 1)
  if (pin[1L] > pin[2L]) 
    xlim <- (pin[1L]/pin[2L]) * xlim
  else ylim <- (pin[2L]/pin[1L]) * ylim
  dev.hold()
  on.exit(dev.flush())
  plot.window(xlim, ylim, "", asp = 1)
  if (is.null(col)) 
    col <- if (is.null(density)) 
      c("white", "lightblue", "mistyrose", "lightcyan", 
        "lavender", "cornsilk")
  else par("fg")
  if (!is.null(col)) 
    col <- rep_len(col, nx)
  if (!is.null(border)) 
    border <- rep_len(border, nx)
  if (!is.null(lty)) 
    lty <- rep_len(lty, nx)
  angle <- rep(angle, nx)
  if (!is.null(density)) 
    density <- rep_len(density, nx)
  twopi <- if (clockwise) 
    -2 * pi
  else 2 * pi
  t2xy <- function(t) {
    t2p <- twopi * t + init.angle * pi/180
    list(x = radius * cos(t2p), y = radius * sin(t2p))
  }
  for (i in 1L:nx) {
    n <- max(2, floor(edges * dx[i]))
    P <- t2xy(seq.int(x[i], x[i + 1], length.out = n))
    polygon(c(P$x, 0), c(P$y, 0), density = density[i], angle = angle[i], 
            border = border[i], col = col[i], lty = lty[i])
    P <- t2xy(mean(x[i + 0:1]))
    lab <- as.character(labels[i])
    if (!is.na(lab) && nzchar(lab)) {
      lines(c(1, 1.05) * P$x, c(1, 1.05) * P$y)
      text(1.1 * P$x, 1.1 * P$y, labels[i], xpd = TRUE, 
           adj = ifelse(P$x < 0, 1, 0), ...)
    }
  }
  title(main = main, ...)
  invisible(NULL)
}
### ================ other routines ===================

#' Creates a CLM header list-object for LPJmL
#'
#' Creates a header from scratch which can be saved to a file using
#' function writeheader()
#' Parameters without defaults that you always need to provide:
#' nyear, ncell, nbands
#'
#' @param name header name (default "LPJGRID")
#' @param version header CLM version (default 2)
#' @param order order of data items , either CELLYEAR (1) or YEARCELL (2) (default 1)
#' @param firstyear first year for data (default 1901)
#' @param nyear number of years contained in file
#' @param firstcell index of first data item (default 0)
#' @param ncell number of data items per year
#' @param nbands number of data elements per cell
#' @param cellsize_lon longitude cellsize in deg (default 0.5)
#' @param cellsize_lat latitude cellsize in deg (default 0.5)
#' @param scalar conversion factor (default 1)
#' @param datatyp data type in file (default 1)
#' @param endian endianness (default copied from local platform -- .Platform$endian)
#'
#' @return list-object with header content
#'
#' @examples
#' \dontrun{
#' new_header(name="LPJGRID", version=2, order=1, firstyear=1901, nyear=1, firstcell=0, ncell=67420, nbands=1, cellsize_lon=0.5, scalar=1, cellsize_lat=cellsize_lon, datatype=1, endian=.Platform$endian)
#' }
#'
#' @export
new_header <- function(name="LPJGRID", version=3, order=1, firstyear=1901, nyear, firstcell=0, ncell, nbands, cellsize_lon=0.5, scalar=1, cellsize_lat=cellsize_lon, datatype=1, endian=.Platform$endian) {
  header <- list()
  if(is.character(name) && length(name) == 1) {
    header[["name"]] <- name
  } else {
    stop("name must be a character vector of length 1")
  }
  header[["header"]] <- numeric(0)
  for(check in c("version", "order", "firstyear", "nyear", "firstcell", "ncell", "nbands")) {
    if(is.numeric(get(check)) && length(get(check)) == 1 && get(check)==as.integer(get(check))) {
      header[["header"]] <- c(header[["header"]], get(check))
      names(header[["header"]])[length(header[["header"]])] <- check
    } else {
      stop(paste(check, "must be an integer of length 1"))
    }
  }
  if(version >= 2) {
    for(check in c("cellsize_lon", "scalar")) {
      if(is.numeric(get(check)) && length(get(check)) == 1) {
        header[["header"]] <- c(header[["header"]], get(check))
        names(header[["header"]])[length(header[["header"]])] <- check
      } else {
        stop(paste(check, "must be a float of length 1"))
      }
    }
    if(version >= 3) {
      if(is.numeric(cellsize_lat) && length(cellsize_lat)==1) {
        header[["header"]] <- c(header[["header"]], cellsize_lat=cellsize_lat)
      } else {
        stop("cellsize_lat must be a float of length 1")
      }
      if(length(datatype)==1) {
        if(!is.null(LPJ_datatype(c(header[["header"]], datatype=datatype)))) {
          header[["header"]] <- c(header[["header"]], datatype=datatype)
          print(paste("Setting datatype to", typeof(LPJ_datatype(header)$type), "with size", LPJ_datatype(header)$size))
        } else {
          stop(paste("Unknown datatype", datatype))
        }
      } else {
        stop("datatype must be integer of length 1")
      }
    }
  }
  header[["endian"]] <- endian
  return(header)
}

#' Get R-specific datatype and size from LPJmL header CLM3
#'
#' This function only works properly with headers of CLM version3 !
#' it can be used within readBin()                         
#' given an LPJ file header (as returned by readheader()),   
#' it returns a list with 2 items:                                             
#' - datatype (to be used as the "what" parameter in readBin()            
#' - size (to be used as the "size" parameter in readBin()            
#' datatypes as currently implemented:                                
#' 0: character (size 1)                                              
#' 1: short (integer size 2)                                          
#' 2: integer (integer size 4)                                        
#' 3: float (numeric size 4)                                          
#' 4: double (numeric size 8)
#'
#' @param header header list
#'
#' @return list(datatype,size)
#'
#' @examples
#' \dontrun{
#' LPJ_datatype(header=header)
#' }
#'
#' @export
LPJ_datatype <- function(header) {
  if(is.list(header))
    header <- header$header
  if(!is.finite(as.integer(header["datatype"]))) {
    stop("Error in LPJ_datatype: header does not contain datatype field")
  }
  return(switch(as.integer(header["datatype"])+1, list(type=character(), size=1), list(type=integer(), size=2), list(type=integer(), size=4), list(type=double(), size=4), list(type=double(), size=8)))
}

#' Computes header size from header list
#'
#' this function can be used within seek() to skip over a header                       
#' (e.g. from readheader()) in a LPJmL input file
#'
#' @param header header list
#'
#' @return byte size of header
#'
#' @examples
#' \dontrun{
#' headersize(header=header)
#' }
#'
#' @export
headersize <- function(header) {
  if(!is.list(header)) {
    stop("Error in headersize: header must be a list")
  }
  if(!("name" %in% names(header)) || !("version" %in% names(header$header))) {
    stop("Error in headersize: invalid header")
  }
  return(nchar(header$name)+switch(as.integer(header$header["version"]), 7, 9, 11)*4)
}

#' Computes cellarea of ordinary lat/lon grids
#'
#' this function computes gridcell areas in m2 based on latitude                   
#' coordinate and angular cell size (resolution), assuming the earth
#' to be a sphere
#' lat can be a vector, res.lon and res.lat be single
#' values.   
#' 
#' @param lat vector of latutidinal grid-midpoints
#' @param res.lon resolution (degree) in longitude dimension (default 0.5)
#' @param res.lat resolution (degree) in latitude dimension (default res.lon)
#'
#' @return vector of cellsizes in m2
#'
#' @examples
#' \dontrun{
#' cellarea(header=header)
#' }
#'
#' @export
cellarea <- function(lat, res.lon=0.5, res.lat=res.lon) {
  earthradius <- 6371000.785
  cellwidth <- earthradius*pi/180
  return((cellwidth*res.lon)*(cellwidth*res.lat)*cos(lat/180*pi))
}

#' Create a raster object from an LPJmL data array
#'
#' Create a raster object from an LPJmL data array and the corresponding lat/lon arrays
#'
#' @param lpjarray lpjml array filled with data dim(lpjmlarray)==c(ncells). ncells==67420 for 30min resolution, or ncells==2298847 for 5min resolution
#' @param lat latitude vector of lpj array
#' @param lon longitude vector of lpj array
#'
#' @return ra raster object filled with the lpjml data on land
#'
#' @examples
#' \dontrun{
#' lpj2raster(lpjarray=discharge2000,lat=lat,lon=lon)
#' }
#' 
#' @export
lpj2raster <- function(lpjarray,lat,lon){
    ncells=length(lat)
    if (ncells==67420){  # 30min resolution 
      ra <- raster::raster(ncols=720, nrows=360)
    }else if (ncells==2298847){ # 5min res
      ra <- raster::raster(ncols=360*12, nrows=180*12)
    }
    range <- range(lpjarray)
    ra[raster::cellFromXY(ra,cbind(lon,lat))] <-  lpjarray
    return(ra)
  }
  
#' Show the full drainage route for cell ind
#'
#' Show the full downstream drainage route for cell ind until final drainage (ocean or inland sink)
#'
#' @param ind cell index to look at
#' @param routingTable routing table obtained from reading in drainage network and adding 1, listing for each cell the next cell discharge is routed to and for sinks -0
#'
#' @return list of downstream cells 
#'
#' @examples
#' \dontrun{
#' showRoute(ind=20000,routingTable=routing)
#' }
#' 
#' @export
showRoute <- function(ind,routingTable){
    if (routingTable[ind]<1){return(ind)} #can be 0 or -8 -> endcell or nacell
    else{return(c(ind,showRoute(routingTable[ind],routingTable)))}
  }

#' Return next direct upstream cells for cell ind
#'
#' Return a list of the next direct upstream cells for cell ind (draining into ind)
#'
#' @param ind cell index to look at
#' @param routingTable routing table obtained from reading in drainage network and adding 1, listing for each cell the next cell discharge is routed to and for sinks -0
#'
#' @return list of direct (neighboring) upstream cells 
#'
#' @examples
#' \dontrun{
#' upstreamCells(ind=20000,routingTable=routing)
#' }
#' 
#' @export
upstreamCells <- function(ind,routingTable){
    return(which(routingTable==ind))
  }

#' Calculate environmental flow requirements (EFRs)
#'
#' Calculate environmental flow requirements (EFRs), based on 30 years of monthly discharge input
#'
#' @param discharge 30 years monthly discharge array dim(discharge)=c(ncells,12,30)
#' @param method EFR method to be used ("VMF","Q90Q50","PBpaper"), "PBpaper" is the modified version of VMF used for the Steffen et al. 2015 PB paper
#'
#' @return EFRs as volumes like in discharge input, dim(EFRs)=c(ncells,12)
#'
#' @examples
#' \dontrun{
#' calcEFRs(discharge=mdischarge_preindustrial,method="VMF")
#' }
#' 
#' @export
calcEFRs <- function(discharge,method="VMF"){
    ncells=dim(discharge)[1]
    efrMethodsSet = c("PBpaper","VMF","Q90Q50")
    #method valid?
    if (!method %in% efrMethodsSet){
      print(paste("EFR method not recognized, use one of: ",paste(efrMethodsSet,collapse = " ")))
      return(NA)
    }
    #make sure discharge is a ncells,12month,30year array
    if (!all(dim(discharge) == c(ncells,12,30))){
      print(paste("discharge array has wrong dimension, use c(ncells,nmonths=12,nyears=30)"))
      return(NA)
    }
    efrs=discharge[,,1]*0 #initialize efrs array
    
    #calculate mean monthly flow and mean annual flow
    MMF=apply(discharge,c(1,2),mean)
    quantiles=apply(discharge,c(1,2),quantile,probs=c(0.5,0.9),na.rm=T)
    MAF=rep(rowMeans(MMF),times=12)
    dim(MAF)=c(ncells,12)
    Q90=quantiles[2,,]
    Q50=quantiles[1,,]
    remove(quantiles)
    
    if (method==efrMethodsSet[1]){ #"PBpaper" - Steffen et al. 2015
      efrs[MMF<=0.4*MAF]=0.75*MMF[MMF<=0.4*MAF] # low flow months
      efrs[MMF>0.4*MAF & MMF<=0.8*MAF]=0.7*MMF[MMF>0.4*MAF & MMF<=0.8*MAF] # intermediate flow months
      efrs[MMF>0.8*MAF]=0.45*MMF[MMF>0.8*MAF] # high flow months
    }else if (method==efrMethodsSet[2]){ # "VMF" - Pastor et al. 2014
      efrs[MMF<=0.4*MAF]=0.6*MMF[MMF<=0.4*MAF] # low flow months
      efrs[MMF>0.4*MAF & MMF<=0.8*MAF]=0.45*MMF[MMF>0.4*MAF & MMF<=0.8*MAF] # intermediate flow months
      efrs[MMF>0.8*MAF]=0.3*MMF[MMF>0.8*MAF] # high flow months
    }else if (method==efrMethodsSet[3]){ # "Q90Q50" - Pastor et al. 2014
      efrs[MMF<=MAF]=Q90[MMF<=MAF] # low flow months
      efrs[MMF>MAF]=Q50[MMF>MAF] # high flow months
    }
    return(efrs)
}

#' Return flow season
#'
#' Return flow season based on the chosen EFR method. "l" (low flow), "i" (intermediate - if applicable), or "h" (high flow)
#'
#' @param discharge 30 years monthly discharge array dim(discharge)=c(ncells,12,30)
#' @param method EFR method to be used ("VMF","Q90Q50","PBpaper"), "PBpaper" is the modified version of VMF used for the Steffen et al. 2015 PB paper
#'
#' @return flow season array:  "l" (low flow), "i" (intermediate - if applicable), or "h" (high flow)
#'
#' @examples
#' \dontrun{
#' flowSeason(discharge=mdischarge_preindustrial,method="VMF")
#' }
#' 
#' @export
flowSeason <- function(discharge,method="VMF"){
    ncells=dim(discharge)[1]
    efrMethodsSet = c("PBpaper","VMF","Q90Q50")
    #method valid?
    if (!method %in% efrMethodsSet){
      print(paste("EFR method not recognized, use one of: ",paste(efrMethodsSet,collapse = " ")))
      return(NA)
    }
    #make sure discharge is a ncells,12month array
    if (!all(dim(discharge) == c(ncells,12))){
      print(paste("discharge array has wrong dimension, use c(ncells,nmonths=12)"))
      return(NA)
    }
    fs=discharge*0 #initialize fs array
    
    #calculate mean monthly flow and mean annual flow
    MMF=discharge
    MAF=rep(rowMeans(MMF),times=12)
    dim(MAF)=c(ncells,12)
    
    if (method==efrMethodsSet[1]){ #"PBpaper" - Steffen et al. 2015
      fs[MMF<=0.4*MAF]="l"
      fs[MMF>0.4*MAF & MMF<=0.8*MAF]="i"
      fs[MMF>0.8*MAF]="h"
    }else if (method==efrMethodsSet[2]){ # "VMF" - Pastor et al. 2014
      fs[MMF<=0.4*MAF]=1#"l"
      fs[MMF>0.4*MAF & MMF<=0.8*MAF]=2#"i"
      fs[MMF>0.8*MAF]=3#"h"
    }else if (method==efrMethodsSet[3]){ # "Q90Q50" - Pastor et al. 2014
      fs[MMF<=MAF]="l"
      fs[MMF>MAF]="h"
    }
    
    return(fs)
  }

#' Aggregate from daily values to monthly values
#'
#' Function to aggregate from daily values to monthly values. Can also be applied for several year arrays:
#' apply(X = daily_discharge,MARGIN = c(1,3),FUN = daily2monthly,method="sum")
#' with dim(daily_discharge)=c(67420,365,30)
#'
#' @param daily array with daily values dim(daily)=c(365)
#' @param method function for aggregation: sum or mean
#'
#' @return monthly array 
#'
#' @examples
#' \dontrun{
#' daily2monthly(daily=ddischarge,method="sum")
#' }
#' 
#' @export
daily2monthly <- function(daily,method="sum"){
    nDays=c(31,28,31,30,31,30,31,31,30,31,30,31)
    if (!length(daily)==365) print("Error - input is not in daily format")
    monthly=array(0,dim=c(12))
    for (m in 1:12){
      if (m==1) fdom=1
      else fdom=sum(nDays[1:(m-1)])+1
      ldom=fdom+nDays[m]-1
      if (method=="sum"){
        monthly[m]=sum(daily[fdom:ldom])
      }else if (method=="mean"){
        monthly[m]=mean(daily[fdom:ldom])
      }else print("Error - method not recognized")
    }
    return(monthly)
  }

#' Remove highflows from a discharge input
#'
#' Remove highflows (above the given quantile) from a discharge input and return the modified discharge
#'
#' @param ddischarge daily discharge input
#' @param threshold all highflows above this quantile (0.9 for Q90) will be removed 
#' @param period calculate the highflows based on all days from all years ("all"), separately for each year ("year"), or just from the days which have positive discharge ("posDischarge")
#'
#' @return modified discharge array with the highflows removed
#'
#' @examples
#' \dontrun{
#' removeHighFlows(ddischarge=daily_discharge_preindustrial,threshold=0.8,period="year")
#' }
#' 
#' @export
removeHighFlows <- function(ddischarge,threshold=0.9,period="all"){
    years=dim(ddischarge)[3]
    #make sure discharge is a ncells,365,X array
    if (!all(dim(ddischarge)[1:2] == c(ncells,365))){
      print(paste("discharge array has wrong dimension, use c(ncells,ndays=365)"))
      return(NA)
    }
    if (period=="all"){
      daily_quantiles=apply(ddischarge,c(1),quantile,probs=c(threshold))
      dailyQ90=rep(daily_quantiles,years*365)
      dim(dailyQ90)=c(ncells,365,years)
    }else if (period=="year"){
      daily_quantiles=apply(ddischarge,c(1,3),quantile,probs=c(threshold))
      dailyQ90=rep(daily_quantiles,365)
      dim(dailyQ90)=c(ncells,years,365)
      dailyQ90=aperm(dailyQ90,c(1,3,2))
    }else if (period=="posDischarge"){
      a=ddischarge
      a[a==0]=NA
      daily_quantiles=apply(a,c(1),quantile,probs=c(threshold),na.rm=T)
      dailyQ90=rep(daily_quantiles,years*365)
      dim(dailyQ90)=c(ncells,365,years)
    }else{
      print(paste("parameter period needs to be set as 'all', 'posDischarge' or 'year'"))
      return(NA)
    }
    ddischarge[ddischarge>dailyQ90]=0
    return(ddischarge)
  }

#' Aggregate LPJmL to country level
#'
#' Aggregates all data in lpjml format to country level, using the aggregation Method provided (e.g. sum, mean)
#'
#' @param input lpjml array to be aggregated c(ncells)
#' @param cowList country-list giving the country code for each LPJmL cell dim=c(ncells)
#' @param aggMethod method to aggregate data to country level ("sum" - e.g. for precipitation - or "mean" - e.g. for temperatures)
#'
#' @return country-array
#'
#' @examples
#' aggregateLPJmLdata2Country(input=surface_temperature,cowList=cowList,aggMethod="mean")
#'
#' @export
aggregateLPJmLdata2Country <- function(input,cowList,aggMethod="sum"){
  clist=sort(unique(cowList))
  dataList=array(0,dim=length(clist))
  for (c in 1:length(dataList)){
    if (aggMethod=="sum"){
      dataList[c]=sum(input[which(cowList==clist[c])])
    }else if (aggMethod=="mean"){
      dataList[c]=mean(input[which(cowList==clist[c])])
    }else{print("Unknown aggregation Method aggMethod")}
  }
  rownames(dataList)=clist
  return(dataList)
}