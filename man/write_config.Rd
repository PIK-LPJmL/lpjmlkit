% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/write_config.R
\name{write_config}
\alias{write_config}
\title{Write a LPJmL config JSON file}
\usage{
write_config(
  params,
  model_path,
  output_path = NULL,
  output_list = c(),
  output_format = "raw",
  js_filename = "lpjml.js",
  parallel_cores = 4
)
}
\arguments{
\item{params}{a tibble/data frame in a defined format (see details)}

\item{model_path}{character string providing the path to LPJmL
(equal to LPJROOT)}

\item{output_path}{character string - if output_path should differ from
model_path - provide a path where an output, a restart and a configuration
folder that will be containing each files are created}

\item{output_list}{character vector containing the \strong{id} of outputvars.
If defined only these defined outputs will be written. Defaults to NULL}

\item{output_format}{character string defining the format of the output.
Defaults to \code{"raw"}, further options would be \code{"cdf"} (write netcdf) or
\code{"clm"} (use a header)}

\item{js_filename}{character string providing name of the main js file to be
parsed. Default is "lpjml.js"}

\item{parallel_cores}{integer defining the number of available CPU cores for
parallelization. Defaults to 4 (min)}
}
\value{
tibble with at least columns "sime_name" defined.
If defined in params pseude parameters "order" and dependency are included.
Tibble in this format is required for \link[lpjmlKit]{submit_lpjml}.
}
\description{
Requires a tibble/data frame in a defined format (see details) and writes
model configuration files (config_*.json) based on the parameters set
in each row (corresponds to each model run).
}
\details{
Supply a \link[tibble]{tibble} (or data frame) for \code{params} in the form of
(random example):\tabular{lrlrr}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{pftpar.1.name} \tab \strong{param.k_temp} \tab \strong{firewood} \cr
   scen1 \tab 42 \tab first_tree \tab NA \tab TRUE \cr
   scen2 \tab 404 \tab NA \tab 0.03 \tab FALSE \cr
}


To set a macro (e.g. FROM_RESTART or CHECKPOINT) provide it as a flag in
in bash: "-DFROM_RESTART" "-DCHECKPOINT"\tabular{lrl}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{-DFROM_RESTART} \cr
   scen1_spinup \tab 42 \tab FALSE \cr
   scen1_transient \tab 404 \tab TRUE \cr
}


Another option would be to set two pseudo parameters to link runs with each
other. The macro "-DFROM_RESTART" is not (!) required here, but is
automatically set. Also a complex order is possible, e.g. nested or > 2.\tabular{lrlr}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{order} \tab \strong{dependeny} \cr
   scen1_spinup \tab 1 \tab 1 \tab NA \cr
   scen1_transient \tab 404 \tab 2 \tab scen1_spinup \cr
}

\subsection{Important}{
\itemize{
\item a \strong{sim_name} has to be provided
\item macros as well as the pseudo parameters ("order", "dependency") are
optional but lay the basis for subsequent runs using
\link[lpjmlKit]{submit_lpjml}
\item use R booleans/logical constants, namely \code{TRUE} and \code{FALSE}
\item make sure to set value types correctly, e.g. you may want to use
\code{as.integer()} for integer value columns
\item use a \strong{\link[tibble]{tibble}} over \code{data.frame}, it does not convert
and shows the type of each column, further advantages
\href{https://tibble.tidyverse.org/}{here}
}
}
}
\examples{
\dontrun{
library(tibble)

# basic
my_params <- tibble(
 sim_name = c("scen1", "scen2"),
 random_seed = as.integer(c(12, )),
 pftpar.1.name = c("first_tree", NA),
 param.k_temp = c(NA, 0.03),
 firewood = c(TRUE, FALSE)
)

config_names <- write_config(params = my_params)
config_names
#   sim_name  random_seed  pftpar.1.name  param.k_temp  `firewood`
#   <chr>           <int>  <chr>                 <dbl>  <lgl>     
# 1 scen1              42  first_tree               NA  TRUE      
# 2 scen2             404  NA                     0.03  FALSE     

# defining macros
my_params2 <- tibble(
 sim_name = c("scen1_spinup", "scen1_transient"),
 random_seed = as.integer(c(42, 666)),
 `-DFROM_RESTART` = c(FALSE, TRUE)
)

config_names2 <- write_config(params = my_params)
config_names2
#   sim_name        random_seed `-DFROM_RESTART`
#   <chr>                 <int> <lgl>           
# 1 scen1_spinup             42 FALSE           
# 2 scen1_transient         666 TRUE            

# with dependent runs
my_params3 <- tibble(
 sim_name = c("scen1_spinup", "scen1_transient"),
 random_seed = as.integer(c(42, 666)),
 order = c(FALSE, TRUE),
 dependency = c(NA, "scen1_spinup")
)
#' config_names3 <- write_config(params = my_params)

config_names3
#   sim_name        random_seed order dependency  
#   <chr>                 <int> <lgl> <chr>       
# 1 scen1_spinup             42 FALSE NA          
# 2 scen1_transient         666 TRUE  scen1_spinup

}
}
