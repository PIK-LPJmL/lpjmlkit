% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/writeConfig.R
\name{writeConfig}
\alias{writeConfig}
\title{Write a LPJmL config JSON file}
\usage{
writeConfig(
  params,
  model_path,
  output_path = NULL,
  output_list = c(),
  output_format = "clm",
  js_filename = "lpjml.js",
  parallel_cores = 4
)
}
\arguments{
\item{params}{a tibble/data frame in a defined format (see details)}

\item{model_path}{character string providing the path to LPJmL
(equal to LPJROOT)}

\item{output_path}{character string - if output_path should differ from
model_path - provide a path where an output, a restart and a configuration
folder that will be containing each files are created}

\item{output_list}{character vector containing the \strong{id} of outputvars.
If defined only these defined outputs will be written. Defaults to NULL}

\item{output_format}{character string defining the format of the output.
Defaults to \code{"clm"} (use a header), further options would be \code{"cdf"} or
\code{"raw"}}

\item{js_filename}{character string providing name of the main js file to be
parsed. Default is "lpjml.js"}

\item{parallel_cores}{integer defining the number of available CPU cores for
parallelization. Defaults to 4 (min)}
}
\value{
tibble with at least columns "sime_name" and "config_file" defined.
If defined in params pseude parameters "order" and dependency are included.
Tibble in this format is required for \link[lpjmlKit]{submitLPJmL}.
}
\description{
Requires a tibble/data frame in a defined format (see details) and writes
model configuration files (config_*.json) based on the parameters set
in each row (corresponds to each model run).
}
\details{
Supply a \link[tibble]{tibble} (or data frame) for \code{params} in the form of
(random example):\tabular{lrlrr}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{pftpar.1.name} \tab \strong{param.k_temp} \tab \strong{firewood} \cr
   scen1 \tab 42 \tab first_tree \tab NA \tab TRUE \cr
   scen2 \tab 404 \tab NA \tab 0.03 \tab FALSE \cr
}


To set a macro (e.g. FROM_RESTART or CHECKPOINT) provide it as a flag in
in bash: "-DFROM_RESTART" "-DCHECKPOINT"\tabular{lrl}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{-DFROM_RESTART} \cr
   scen1_spinup \tab 42 \tab FALSE \cr
   scen1_transient \tab 42 \tab TRUE \cr
}


Another option would be to set two pseudo parameters to link runs with each
other. The macro "-DFROM_RESTART" is not (!) required here, but is
automatically set. Also a complex order is possible, e.g. nested or > 2.\tabular{lrlr}{
   \strong{sim_name} \tab \strong{random_seed} \tab \strong{order} \tab \strong{dependeny} \cr
   scen1_spinup \tab 42 \tab 1 \tab NA \cr
   scen1_transient \tab 42 \tab 2 \tab scen1_spinup \cr
}

\subsection{Important}{
\itemize{
\item a \strong{sim_name} has to be provided
\item macros as well as the pseudo parameters ("order", "dependency") are
optional but lay the basis for subsequent runs using
\link[lpjmlKit]{submitLPJmL}
\item use R booleans/logical constants, namely \code{TRUE} and \code{FALSE}
\item make sure to set value types correctly, e.g. you may want to use
\code{as.integer()} for integer value columns
\item use a \strong{\link[tibble]{tibble}} over \code{data.frame}, it does not convert
and shows the type of each column, further advantages
\href{https://tibble.tidyverse.org/}{here}
}
}
}
\examples{
\dontrun{
my_params <- tibble::tibble(
 sim_name = c("scen1", "scen2"),
 random_seed = as.integer(c(42, 666)),
 pftpar.1.name = c("first_tree", NA),
 param.k_temp = c(NA, 0.03),
 firewood = c(TRUE, FALSE)
)

config_names <- writeConfig(params = my_params)

  sim_name  random_seed  pftpar.1.name  param.k_temp  `firewood`
  <chr>           <int>  <chr>                 <dbl>  <lgl>     
1 scen1               5  first_tree               NA  TRUE      
2 scen2               4  NA                     0.03  FALSE     
}
}
