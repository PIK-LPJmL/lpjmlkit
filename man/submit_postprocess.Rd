% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/submit_postprocess.R
\name{submit_postprocess}
\alias{submit_postprocess}
\title{Submit a post model process to SLURM}
\usage{
submit_postprocess(
  x = NULL,
  select_sim = NULL,
  output_path,
  fun,
  args,
  sim_name_arg = "x",
  sim_name_path = FALSE,
  group = "lpjml",
  sclass = "short",
  ntasks = 1,
  return_output = FALSE,
  package_names = NULL,
  memory = NULL,
  modules = NULL,
  no_submit = FALSE
)
}
\arguments{
\item{x}{A tibble generated by submit_lpjml or character vector of
sim_names (output folders) within the output_path directory. If NULL
(default) \code{output_path} is used directly to store stdout, stderr.}

\item{select_sim}{Character vector. Select the simulations to be post
processed by their sim_name (output folders). This may be relevant if some
of the simulations are Spin-up runs or should not be included directly be
processed (e.g. PNV runs). Defaults to NULL.}

\item{output_path}{Character string defining the path to create a postprocess
folder, a subfolder for each \code{x} -> \emph{sim_name} (if provided) as a template
and to store stdout, stderr files.}

\item{fun}{Either a function object or a non-empty character string naming
the function to be passed to be submitted.}

\item{args}{A list of arguments to the \code{fun} call. The names attribute
of args gives the argument names. \strong{IMPORTANT} \code{fun} has to have an argument
which acts as a placeholder to be filled with each \emph{sim_name} of
\code{x}/\code{select_sim}. If it should not be \code{x} please specify via \code{sim_name_arg}.}

\item{sim_name_arg}{Character string defining the functions \code{fun} argument the
internally iterated \emph{sim_name} is passed to. This argument cannot be defined
and works as a placeholder. Defaults to "x".}

\item{sim_name_path}{Logical. If \code{TRUE} the \emph{sime_name} is concatenated
to a path name as \code{paste(output_path, "output", sim_name, sep="/")} and passed
this way to the \code{sim_name_arg}. Defaults to \code{FALSE}.}

\item{group}{Character string, provides a group for which the job is
submitted. Default is "lpjml".}

\item{sclass}{Character string, defines the job classification, for more
information have a look \href{https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5}{here}. # nolint
Defaults to "short".}

\item{ntasks}{integer, defines the number of tasks/threads, for more
information have a look \href{https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18}{here}. # nolint
Defaults to 1.}

\item{return_output}{Logical. If \code{TRUE} the output of the function is saved
as an \emph{RDS} file to the \code{output_path} -> postprocess with fun_name.
Defaults to FALSE.}

\item{package_names}{Character vector. Provides package names of the functions
to be used, or functions to be used inside if not called via
package::function annotation. Defaults to NULL.}

\item{memory}{Integer. If a function requires a lot of RAM allocate required
memory (in mb). Defaults to NULL.}

\item{modules}{Character vector. Modules to be loaded on the cluster. Please
keep in mind that \verb{module purge} is executed before the modules are loaded.
Defaults to NULL.}

\item{no_submit}{Logical. If TRUE the job is not submitted to SLURM - this
feature is' mostly for testing purpose.}
}
\value{
See \code{x}, extended by columns fun_name and dependency, order if
missing.
}
\description{
Postprocess functions are submitted to SLURM based on submitted LPJmL runs
\link[lpjmlkit]{submit_lpjml}. \code{submit_lpjml} returns a tibble that can be
used as an input (see \code{x}). It serves the details to submit single
or multiple (dependent/subsequent) postprocess runs.
}
\examples{

\dontrun{
library(lpjmlkit)
library(tibble)

model_path <- paste0("/home/",Sys.getenv("USER"), "/LPJmL_internal")
output_path <-paste0("/home/",Sys.getenv("USER"), "/my_runs")

job_details <- tibble(
  sim_name = c("scen1_spinup", "scen1_transient"),
  random_seed = as.integer(c(1, 42)),
  order = c(1, 2),
  dependency = c(NA, "scen1_spinup")
) \%>\%
  write_config(model_path, output_path) \%>\%
  submit_lpjml(model_path, output_path) \%>\%
  submit_postprocess(select_sim = c("scen1_transient"),
                     output_path = output_path,
                     fun = print,
                     args = list())

job_details
#   sim_name        fun_file                 order dependency        job_id status
#   <chr>           <chr>                    <dbl> <chr>              <dbl> <chr>
# 1 scen1_spinup    NA                           1 NA               2123724 submitted
# 2 scen1_transient NA                           2 scen1_spinup     2123725 submitted
# 3 scen1_transient print                        3 scen1_spinup (2) 2123726 submitted
}

}
