% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/submit_postprocess.R
\name{submit_postprocess}
\alias{submit_postprocess}
\title{Submit postprocess}
\usage{
submit_postprocess(
  x = NULL,
  select_sim = NULL,
  output_path,
  fun,
  args,
  sim_name_arg = "x",
  sim_name_path = FALSE,
  group = "lpjml",
  sclass = "short",
  ntasks = 1,
  return_output = FALSE,
  package_names = NULL,
  memory = NULL,
  modules = NULL,
  no_submit = FALSE
)
}
\arguments{
\item{x}{job_details tibble generated by submit_lpjml or character vector of
sim_names (output folders) within the output_path directory. If NULL
(default) \code{output_path} is used directly to store stdout, stderr.}

\item{select_sim}{character vector. Select the simulations to be post
processed by their sim_name (output folders). This may be relevant if some
of the simulations are Spin-up runs or should not be included directly be
processed (e.g. PNV runs). Defaults to NULL.}

\item{output_path}{character defining the path to create a postprocess
folder, a subfolder for each \code{x} -> \emph{sim_name} (if provided) as a template
and to store stdout, stderr files.}

\item{fun}{either a function object or a non-empty character string naming
the function to be passed to be submitted.}

\item{args}{a list of arguments to the \code{fun} call. The names attribute
of args gives the argument names. \strong{IMPORTANT} \code{fun} has to have an argument
which acts as a placeholder to be filled with each \emph{sim_name} of
\code{x}/\code{select_sim}. If it should not be \code{x} please specify via \code{sim_name_arg}.}

\item{sim_name_arg}{character string defining the functions \code{fun} argument the
internally iterated \emph{sim_name} is passed to. This argument cannot be defined
and works as a placeholder. Defaults to "x".}

\item{sim_name_path}{boolean. If \code{TRUE} the \emph{sime_name} is concatenated
to a path name as \code{paste(output_path, "output", sim_name, sep="/")} and passed
this way to the \code{sim_name_arg}. Defaults to \code{FALSE}.}

\item{group}{character string, provide a group for which the job is
submitted. Default is "lpjml"}

\item{sclass}{character string, define the job classification, for more
information have a look \href{https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-5}{here}.
Defaults to "short".}

\item{ntasks}{integer, define the number of tasks/threads, for more
information have a look \href{https://www.pik-potsdam.de/en/institute/about/it-services/hpc/user-guides/slurm#section-18}{here}.
Defaults to 1.}

\item{return_output}{boolean. If \code{TRUE} output of function is saved as \emph{RDS}
file to \code{output_path} -> postprocess with fun_name. Defaults to FALSE}

\item{package_names}{character vector. Provide package names of the function
to be used, or functions to be used inside if not called via
package::function annotation. Defaults to NULL}

\item{memory}{integer. If function requires a lot of RAM allocate memory
(in mb). Defaults to NULL}

\item{modules}{character vector. Modules to be load on the cluster. Please
mind that \verb{module purge} is executed before modules are loaded. Defaults to
NULL}

\item{no_submit}{boolean. If TRUE job is not submitted to Slurm - feature is
mostly for testing purpose.}
}
\value{
see \code{x}, extended with columns fun_name and dependence, order if
missing.
}
\description{
postprocess functions are submitted to Slurm based on submitted LPJmL runs
\link[lpjmlKit]{submit_lpjml}. \code{submit_lpjml} returns a tibble that can be
used as an input (see \code{x}). It serves the details to submit single
or multiple (dependent/subsequent) postprocess runs.
}
\examples{

\dontrun{
library(lpjmlKit)
library(tibble)

model_path <- paste0("/home/",Sys.getenv("USER"), "/LPJmL_internal")
output_path <-paste0("/home/",Sys.getenv("USER"), "/my_runs")

job_details <- tibble(
  sim_name = c("scen1_spinup", "scen1_transient"),
  random_seed = as.integer(c(1, 42)),
  order = c(1, 2),
  dependency = c(NA, "scen1_spinup")
) \%>\%
  write_config(model_path, output_path) \%>\%
  submit_lpjml(model_path, output_path) \%>\%
  submit_postprocess(select_sim = c("scen1_transient"),
                     output_path = output_path,
                     fun = print,
                     args = list())

job_details
#   sim_name        fun_file                 order dependency        job_id status  
#   <chr>           <chr>                    <dbl> <chr>              <dbl> <chr>   
# 1 scen1_spinup    NA                           1 NA               2123724 submitted
# 2 scen1_transient NA                           2 scen1_spinup     2123725 submitted
# 3 scen1_transient print                        3 scen1_spinup (2) 2123726 submitted
}

}
